// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: service.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_service_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_service_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_service_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_service_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_service_2eproto;
class AdminGetSpaceInfoRequest;
struct AdminGetSpaceInfoRequestDefaultTypeInternal;
extern AdminGetSpaceInfoRequestDefaultTypeInternal _AdminGetSpaceInfoRequest_default_instance_;
class AdminGetSpaceInfoResponse;
struct AdminGetSpaceInfoResponseDefaultTypeInternal;
extern AdminGetSpaceInfoResponseDefaultTypeInternal _AdminGetSpaceInfoResponse_default_instance_;
class AdminLoginRequest;
struct AdminLoginRequestDefaultTypeInternal;
extern AdminLoginRequestDefaultTypeInternal _AdminLoginRequest_default_instance_;
class AdminLoginResponse;
struct AdminLoginResponseDefaultTypeInternal;
extern AdminLoginResponseDefaultTypeInternal _AdminLoginResponse_default_instance_;
class CarInfo;
struct CarInfoDefaultTypeInternal;
extern CarInfoDefaultTypeInternal _CarInfo_default_instance_;
class CarOperationRequest;
struct CarOperationRequestDefaultTypeInternal;
extern CarOperationRequestDefaultTypeInternal _CarOperationRequest_default_instance_;
class CarOperationResponse;
struct CarOperationResponseDefaultTypeInternal;
extern CarOperationResponseDefaultTypeInternal _CarOperationResponse_default_instance_;
class GetUserDataRequest;
struct GetUserDataRequestDefaultTypeInternal;
extern GetUserDataRequestDefaultTypeInternal _GetUserDataRequest_default_instance_;
class GetUserDataResponse;
struct GetUserDataResponseDefaultTypeInternal;
extern GetUserDataResponseDefaultTypeInternal _GetUserDataResponse_default_instance_;
class UserLoginRequest;
struct UserLoginRequestDefaultTypeInternal;
extern UserLoginRequestDefaultTypeInternal _UserLoginRequest_default_instance_;
class UserLoginResponse;
struct UserLoginResponseDefaultTypeInternal;
extern UserLoginResponseDefaultTypeInternal _UserLoginResponse_default_instance_;
class UserRegistrationRequest;
struct UserRegistrationRequestDefaultTypeInternal;
extern UserRegistrationRequestDefaultTypeInternal _UserRegistrationRequest_default_instance_;
class UserRegistrationResponse;
struct UserRegistrationResponseDefaultTypeInternal;
extern UserRegistrationResponseDefaultTypeInternal _UserRegistrationResponse_default_instance_;
PROTOBUF_NAMESPACE_OPEN
template<> ::AdminGetSpaceInfoRequest* Arena::CreateMaybeMessage<::AdminGetSpaceInfoRequest>(Arena*);
template<> ::AdminGetSpaceInfoResponse* Arena::CreateMaybeMessage<::AdminGetSpaceInfoResponse>(Arena*);
template<> ::AdminLoginRequest* Arena::CreateMaybeMessage<::AdminLoginRequest>(Arena*);
template<> ::AdminLoginResponse* Arena::CreateMaybeMessage<::AdminLoginResponse>(Arena*);
template<> ::CarInfo* Arena::CreateMaybeMessage<::CarInfo>(Arena*);
template<> ::CarOperationRequest* Arena::CreateMaybeMessage<::CarOperationRequest>(Arena*);
template<> ::CarOperationResponse* Arena::CreateMaybeMessage<::CarOperationResponse>(Arena*);
template<> ::GetUserDataRequest* Arena::CreateMaybeMessage<::GetUserDataRequest>(Arena*);
template<> ::GetUserDataResponse* Arena::CreateMaybeMessage<::GetUserDataResponse>(Arena*);
template<> ::UserLoginRequest* Arena::CreateMaybeMessage<::UserLoginRequest>(Arena*);
template<> ::UserLoginResponse* Arena::CreateMaybeMessage<::UserLoginResponse>(Arena*);
template<> ::UserRegistrationRequest* Arena::CreateMaybeMessage<::UserRegistrationRequest>(Arena*);
template<> ::UserRegistrationResponse* Arena::CreateMaybeMessage<::UserRegistrationResponse>(Arena*);
PROTOBUF_NAMESPACE_CLOSE

enum Alarm : int {
  ALARM_NO = 0,
  ALARM_FIRE = 1,
  ALARM_GAS = 2,
  ALARM_FIRE_AND_GAS = 3,
  Alarm_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  Alarm_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool Alarm_IsValid(int value);
constexpr Alarm Alarm_MIN = ALARM_NO;
constexpr Alarm Alarm_MAX = ALARM_FIRE_AND_GAS;
constexpr int Alarm_ARRAYSIZE = Alarm_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Alarm_descriptor();
template<typename T>
inline const std::string& Alarm_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Alarm>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Alarm_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Alarm_descriptor(), enum_t_value);
}
inline bool Alarm_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Alarm* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Alarm>(
    Alarm_descriptor(), name, value);
}
enum LoginResult : int {
  LOGIN_SUCCESS = 0,
  LOGIN_FAIL_NOT_EXIST = 1,
  LOGIN_FAIL_WRONG_PASSWORD = 2,
  LoginResult_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  LoginResult_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool LoginResult_IsValid(int value);
constexpr LoginResult LoginResult_MIN = LOGIN_SUCCESS;
constexpr LoginResult LoginResult_MAX = LOGIN_FAIL_WRONG_PASSWORD;
constexpr int LoginResult_ARRAYSIZE = LoginResult_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* LoginResult_descriptor();
template<typename T>
inline const std::string& LoginResult_Name(T enum_t_value) {
  static_assert(::std::is_same<T, LoginResult>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function LoginResult_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    LoginResult_descriptor(), enum_t_value);
}
inline bool LoginResult_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, LoginResult* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<LoginResult>(
    LoginResult_descriptor(), name, value);
}
enum RegistrationResult : int {
  REGISTRATION_SUCCESS = 0,
  REGISTRATION_FAIL_ALREADY_EXIST = 1,
  RegistrationResult_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  RegistrationResult_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool RegistrationResult_IsValid(int value);
constexpr RegistrationResult RegistrationResult_MIN = REGISTRATION_SUCCESS;
constexpr RegistrationResult RegistrationResult_MAX = REGISTRATION_FAIL_ALREADY_EXIST;
constexpr int RegistrationResult_ARRAYSIZE = RegistrationResult_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* RegistrationResult_descriptor();
template<typename T>
inline const std::string& RegistrationResult_Name(T enum_t_value) {
  static_assert(::std::is_same<T, RegistrationResult>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function RegistrationResult_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    RegistrationResult_descriptor(), enum_t_value);
}
inline bool RegistrationResult_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, RegistrationResult* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<RegistrationResult>(
    RegistrationResult_descriptor(), name, value);
}
enum CarOperation : int {
  OPERATION_ADD = 0,
  OPERATION_DELETE = 1,
  OPERATION_CHANGE = 2,
  CarOperation_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  CarOperation_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool CarOperation_IsValid(int value);
constexpr CarOperation CarOperation_MIN = OPERATION_ADD;
constexpr CarOperation CarOperation_MAX = OPERATION_CHANGE;
constexpr int CarOperation_ARRAYSIZE = CarOperation_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* CarOperation_descriptor();
template<typename T>
inline const std::string& CarOperation_Name(T enum_t_value) {
  static_assert(::std::is_same<T, CarOperation>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function CarOperation_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    CarOperation_descriptor(), enum_t_value);
}
inline bool CarOperation_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, CarOperation* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<CarOperation>(
    CarOperation_descriptor(), name, value);
}
enum CarOperationResult : int {
  OPERATION_ADD_SUCCESS = 0,
  OPERATION_ADD_FAIL_ALREADY_EXIST = 1,
  OPERATION_ADD_FAIL_USER_NOT_EXIST = 2,
  OPERATION_DELETE_SUCCESS = 3,
  OPERATION_DELETE_FAIL_ENTERED = 4,
  OPERATION_DELETE_FAIL_NOT_EXIST = 5,
  OPERATION_DELETE_FAIL_USER_NOT_EXIST = 6,
  OPERATION_CHANGE_SUCCESS = 7,
  OPERATION_CHANGE_FAIL_ENTERED = 8,
  OPERATION_CHANGE_FAIL_NOT_EXIST = 9,
  OPERATION_CHANGE_FAIL_USER_NOT_EXIST = 10,
  CarOperationResult_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  CarOperationResult_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool CarOperationResult_IsValid(int value);
constexpr CarOperationResult CarOperationResult_MIN = OPERATION_ADD_SUCCESS;
constexpr CarOperationResult CarOperationResult_MAX = OPERATION_CHANGE_FAIL_USER_NOT_EXIST;
constexpr int CarOperationResult_ARRAYSIZE = CarOperationResult_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* CarOperationResult_descriptor();
template<typename T>
inline const std::string& CarOperationResult_Name(T enum_t_value) {
  static_assert(::std::is_same<T, CarOperationResult>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function CarOperationResult_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    CarOperationResult_descriptor(), enum_t_value);
}
inline bool CarOperationResult_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, CarOperationResult* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<CarOperationResult>(
    CarOperationResult_descriptor(), name, value);
}
// ===================================================================

class CarInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CarInfo) */ {
 public:
  inline CarInfo() : CarInfo(nullptr) {}
  ~CarInfo() override;
  explicit PROTOBUF_CONSTEXPR CarInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CarInfo(const CarInfo& from);
  CarInfo(CarInfo&& from) noexcept
    : CarInfo() {
    *this = ::std::move(from);
  }

  inline CarInfo& operator=(const CarInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline CarInfo& operator=(CarInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CarInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const CarInfo* internal_default_instance() {
    return reinterpret_cast<const CarInfo*>(
               &_CarInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(CarInfo& a, CarInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(CarInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CarInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CarInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CarInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CarInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CarInfo& from) {
    CarInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CarInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CarInfo";
  }
  protected:
  explicit CarInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPAddressFieldNumber = 4,
    kSDataFieldNumber = 6,
    kPTemperatureFieldNumber = 1,
    kPHumidityFieldNumber = 2,
    kPWeatherFieldNumber = 3,
    kSIdFieldNumber = 5,
  };
  // string p_address = 4;
  void clear_p_address();
  const std::string& p_address() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_p_address(ArgT0&& arg0, ArgT... args);
  std::string* mutable_p_address();
  PROTOBUF_NODISCARD std::string* release_p_address();
  void set_allocated_p_address(std::string* p_address);
  private:
  const std::string& _internal_p_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_p_address(const std::string& value);
  std::string* _internal_mutable_p_address();
  public:

  // string s_data = 6;
  void clear_s_data();
  const std::string& s_data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_s_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_s_data();
  PROTOBUF_NODISCARD std::string* release_s_data();
  void set_allocated_s_data(std::string* s_data);
  private:
  const std::string& _internal_s_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_s_data(const std::string& value);
  std::string* _internal_mutable_s_data();
  public:

  // int32 p_temperature = 1;
  void clear_p_temperature();
  int32_t p_temperature() const;
  void set_p_temperature(int32_t value);
  private:
  int32_t _internal_p_temperature() const;
  void _internal_set_p_temperature(int32_t value);
  public:

  // int32 p_humidity = 2;
  void clear_p_humidity();
  int32_t p_humidity() const;
  void set_p_humidity(int32_t value);
  private:
  int32_t _internal_p_humidity() const;
  void _internal_set_p_humidity(int32_t value);
  public:

  // int32 p_weather = 3;
  void clear_p_weather();
  int32_t p_weather() const;
  void set_p_weather(int32_t value);
  private:
  int32_t _internal_p_weather() const;
  void _internal_set_p_weather(int32_t value);
  public:

  // int32 s_id = 5;
  void clear_s_id();
  int32_t s_id() const;
  void set_s_id(int32_t value);
  private:
  int32_t _internal_s_id() const;
  void _internal_set_s_id(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:CarInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr p_address_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr s_data_;
    int32_t p_temperature_;
    int32_t p_humidity_;
    int32_t p_weather_;
    int32_t s_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2eproto;
};
// -------------------------------------------------------------------

class UserLoginRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:UserLoginRequest) */ {
 public:
  inline UserLoginRequest() : UserLoginRequest(nullptr) {}
  ~UserLoginRequest() override;
  explicit PROTOBUF_CONSTEXPR UserLoginRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UserLoginRequest(const UserLoginRequest& from);
  UserLoginRequest(UserLoginRequest&& from) noexcept
    : UserLoginRequest() {
    *this = ::std::move(from);
  }

  inline UserLoginRequest& operator=(const UserLoginRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline UserLoginRequest& operator=(UserLoginRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UserLoginRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const UserLoginRequest* internal_default_instance() {
    return reinterpret_cast<const UserLoginRequest*>(
               &_UserLoginRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(UserLoginRequest& a, UserLoginRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(UserLoginRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UserLoginRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UserLoginRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UserLoginRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UserLoginRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UserLoginRequest& from) {
    UserLoginRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UserLoginRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "UserLoginRequest";
  }
  protected:
  explicit UserLoginRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUsernameFieldNumber = 1,
    kPasswordFieldNumber = 2,
  };
  // string username = 1;
  void clear_username();
  const std::string& username() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_username(ArgT0&& arg0, ArgT... args);
  std::string* mutable_username();
  PROTOBUF_NODISCARD std::string* release_username();
  void set_allocated_username(std::string* username);
  private:
  const std::string& _internal_username() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_username(const std::string& value);
  std::string* _internal_mutable_username();
  public:

  // string password = 2;
  void clear_password();
  const std::string& password() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_password(ArgT0&& arg0, ArgT... args);
  std::string* mutable_password();
  PROTOBUF_NODISCARD std::string* release_password();
  void set_allocated_password(std::string* password);
  private:
  const std::string& _internal_password() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_password(const std::string& value);
  std::string* _internal_mutable_password();
  public:

  // @@protoc_insertion_point(class_scope:UserLoginRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr username_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr password_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2eproto;
};
// -------------------------------------------------------------------

class UserLoginResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:UserLoginResponse) */ {
 public:
  inline UserLoginResponse() : UserLoginResponse(nullptr) {}
  ~UserLoginResponse() override;
  explicit PROTOBUF_CONSTEXPR UserLoginResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UserLoginResponse(const UserLoginResponse& from);
  UserLoginResponse(UserLoginResponse&& from) noexcept
    : UserLoginResponse() {
    *this = ::std::move(from);
  }

  inline UserLoginResponse& operator=(const UserLoginResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline UserLoginResponse& operator=(UserLoginResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UserLoginResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const UserLoginResponse* internal_default_instance() {
    return reinterpret_cast<const UserLoginResponse*>(
               &_UserLoginResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(UserLoginResponse& a, UserLoginResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(UserLoginResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UserLoginResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UserLoginResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UserLoginResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UserLoginResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UserLoginResponse& from) {
    UserLoginResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UserLoginResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "UserLoginResponse";
  }
  protected:
  explicit UserLoginResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResultFieldNumber = 1,
    kUIdFieldNumber = 2,
  };
  // .LoginResult result = 1;
  void clear_result();
  ::LoginResult result() const;
  void set_result(::LoginResult value);
  private:
  ::LoginResult _internal_result() const;
  void _internal_set_result(::LoginResult value);
  public:

  // int32 u_id = 2;
  void clear_u_id();
  int32_t u_id() const;
  void set_u_id(int32_t value);
  private:
  int32_t _internal_u_id() const;
  void _internal_set_u_id(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:UserLoginResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int result_;
    int32_t u_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2eproto;
};
// -------------------------------------------------------------------

class UserRegistrationRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:UserRegistrationRequest) */ {
 public:
  inline UserRegistrationRequest() : UserRegistrationRequest(nullptr) {}
  ~UserRegistrationRequest() override;
  explicit PROTOBUF_CONSTEXPR UserRegistrationRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UserRegistrationRequest(const UserRegistrationRequest& from);
  UserRegistrationRequest(UserRegistrationRequest&& from) noexcept
    : UserRegistrationRequest() {
    *this = ::std::move(from);
  }

  inline UserRegistrationRequest& operator=(const UserRegistrationRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline UserRegistrationRequest& operator=(UserRegistrationRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UserRegistrationRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const UserRegistrationRequest* internal_default_instance() {
    return reinterpret_cast<const UserRegistrationRequest*>(
               &_UserRegistrationRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(UserRegistrationRequest& a, UserRegistrationRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(UserRegistrationRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UserRegistrationRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UserRegistrationRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UserRegistrationRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UserRegistrationRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UserRegistrationRequest& from) {
    UserRegistrationRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UserRegistrationRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "UserRegistrationRequest";
  }
  protected:
  explicit UserRegistrationRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUsernameFieldNumber = 1,
    kPasswordFieldNumber = 2,
  };
  // string username = 1;
  void clear_username();
  const std::string& username() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_username(ArgT0&& arg0, ArgT... args);
  std::string* mutable_username();
  PROTOBUF_NODISCARD std::string* release_username();
  void set_allocated_username(std::string* username);
  private:
  const std::string& _internal_username() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_username(const std::string& value);
  std::string* _internal_mutable_username();
  public:

  // string password = 2;
  void clear_password();
  const std::string& password() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_password(ArgT0&& arg0, ArgT... args);
  std::string* mutable_password();
  PROTOBUF_NODISCARD std::string* release_password();
  void set_allocated_password(std::string* password);
  private:
  const std::string& _internal_password() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_password(const std::string& value);
  std::string* _internal_mutable_password();
  public:

  // @@protoc_insertion_point(class_scope:UserRegistrationRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr username_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr password_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2eproto;
};
// -------------------------------------------------------------------

class UserRegistrationResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:UserRegistrationResponse) */ {
 public:
  inline UserRegistrationResponse() : UserRegistrationResponse(nullptr) {}
  ~UserRegistrationResponse() override;
  explicit PROTOBUF_CONSTEXPR UserRegistrationResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UserRegistrationResponse(const UserRegistrationResponse& from);
  UserRegistrationResponse(UserRegistrationResponse&& from) noexcept
    : UserRegistrationResponse() {
    *this = ::std::move(from);
  }

  inline UserRegistrationResponse& operator=(const UserRegistrationResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline UserRegistrationResponse& operator=(UserRegistrationResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UserRegistrationResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const UserRegistrationResponse* internal_default_instance() {
    return reinterpret_cast<const UserRegistrationResponse*>(
               &_UserRegistrationResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(UserRegistrationResponse& a, UserRegistrationResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(UserRegistrationResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UserRegistrationResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UserRegistrationResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UserRegistrationResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UserRegistrationResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UserRegistrationResponse& from) {
    UserRegistrationResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UserRegistrationResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "UserRegistrationResponse";
  }
  protected:
  explicit UserRegistrationResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResultFieldNumber = 1,
  };
  // .RegistrationResult result = 1;
  void clear_result();
  ::RegistrationResult result() const;
  void set_result(::RegistrationResult value);
  private:
  ::RegistrationResult _internal_result() const;
  void _internal_set_result(::RegistrationResult value);
  public:

  // @@protoc_insertion_point(class_scope:UserRegistrationResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int result_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2eproto;
};
// -------------------------------------------------------------------

class CarOperationRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CarOperationRequest) */ {
 public:
  inline CarOperationRequest() : CarOperationRequest(nullptr) {}
  ~CarOperationRequest() override;
  explicit PROTOBUF_CONSTEXPR CarOperationRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CarOperationRequest(const CarOperationRequest& from);
  CarOperationRequest(CarOperationRequest&& from) noexcept
    : CarOperationRequest() {
    *this = ::std::move(from);
  }

  inline CarOperationRequest& operator=(const CarOperationRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CarOperationRequest& operator=(CarOperationRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CarOperationRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const CarOperationRequest* internal_default_instance() {
    return reinterpret_cast<const CarOperationRequest*>(
               &_CarOperationRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(CarOperationRequest& a, CarOperationRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(CarOperationRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CarOperationRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CarOperationRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CarOperationRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CarOperationRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CarOperationRequest& from) {
    CarOperationRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CarOperationRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CarOperationRequest";
  }
  protected:
  explicit CarOperationRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLicenseFieldNumber = 3,
    kNewLicenseFieldNumber = 4,
    kOperationFieldNumber = 1,
    kUIdFieldNumber = 2,
  };
  // string license = 3;
  void clear_license();
  const std::string& license() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_license(ArgT0&& arg0, ArgT... args);
  std::string* mutable_license();
  PROTOBUF_NODISCARD std::string* release_license();
  void set_allocated_license(std::string* license);
  private:
  const std::string& _internal_license() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_license(const std::string& value);
  std::string* _internal_mutable_license();
  public:

  // optional string new_license = 4;
  bool has_new_license() const;
  private:
  bool _internal_has_new_license() const;
  public:
  void clear_new_license();
  const std::string& new_license() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_new_license(ArgT0&& arg0, ArgT... args);
  std::string* mutable_new_license();
  PROTOBUF_NODISCARD std::string* release_new_license();
  void set_allocated_new_license(std::string* new_license);
  private:
  const std::string& _internal_new_license() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_new_license(const std::string& value);
  std::string* _internal_mutable_new_license();
  public:

  // .CarOperation operation = 1;
  void clear_operation();
  ::CarOperation operation() const;
  void set_operation(::CarOperation value);
  private:
  ::CarOperation _internal_operation() const;
  void _internal_set_operation(::CarOperation value);
  public:

  // int32 u_id = 2;
  void clear_u_id();
  int32_t u_id() const;
  void set_u_id(int32_t value);
  private:
  int32_t _internal_u_id() const;
  void _internal_set_u_id(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:CarOperationRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr license_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr new_license_;
    int operation_;
    int32_t u_id_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2eproto;
};
// -------------------------------------------------------------------

class CarOperationResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CarOperationResponse) */ {
 public:
  inline CarOperationResponse() : CarOperationResponse(nullptr) {}
  ~CarOperationResponse() override;
  explicit PROTOBUF_CONSTEXPR CarOperationResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CarOperationResponse(const CarOperationResponse& from);
  CarOperationResponse(CarOperationResponse&& from) noexcept
    : CarOperationResponse() {
    *this = ::std::move(from);
  }

  inline CarOperationResponse& operator=(const CarOperationResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline CarOperationResponse& operator=(CarOperationResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CarOperationResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const CarOperationResponse* internal_default_instance() {
    return reinterpret_cast<const CarOperationResponse*>(
               &_CarOperationResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(CarOperationResponse& a, CarOperationResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(CarOperationResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CarOperationResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CarOperationResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CarOperationResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CarOperationResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CarOperationResponse& from) {
    CarOperationResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CarOperationResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CarOperationResponse";
  }
  protected:
  explicit CarOperationResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResultFieldNumber = 1,
  };
  // .CarOperationResult result = 1;
  void clear_result();
  ::CarOperationResult result() const;
  void set_result(::CarOperationResult value);
  private:
  ::CarOperationResult _internal_result() const;
  void _internal_set_result(::CarOperationResult value);
  public:

  // @@protoc_insertion_point(class_scope:CarOperationResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int result_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2eproto;
};
// -------------------------------------------------------------------

class GetUserDataRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:GetUserDataRequest) */ {
 public:
  inline GetUserDataRequest() : GetUserDataRequest(nullptr) {}
  ~GetUserDataRequest() override;
  explicit PROTOBUF_CONSTEXPR GetUserDataRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetUserDataRequest(const GetUserDataRequest& from);
  GetUserDataRequest(GetUserDataRequest&& from) noexcept
    : GetUserDataRequest() {
    *this = ::std::move(from);
  }

  inline GetUserDataRequest& operator=(const GetUserDataRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetUserDataRequest& operator=(GetUserDataRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetUserDataRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetUserDataRequest* internal_default_instance() {
    return reinterpret_cast<const GetUserDataRequest*>(
               &_GetUserDataRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(GetUserDataRequest& a, GetUserDataRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetUserDataRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetUserDataRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetUserDataRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetUserDataRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetUserDataRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetUserDataRequest& from) {
    GetUserDataRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetUserDataRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "GetUserDataRequest";
  }
  protected:
  explicit GetUserDataRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUIdFieldNumber = 1,
  };
  // int32 u_id = 1;
  void clear_u_id();
  int32_t u_id() const;
  void set_u_id(int32_t value);
  private:
  int32_t _internal_u_id() const;
  void _internal_set_u_id(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:GetUserDataRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t u_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2eproto;
};
// -------------------------------------------------------------------

class GetUserDataResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:GetUserDataResponse) */ {
 public:
  inline GetUserDataResponse() : GetUserDataResponse(nullptr) {}
  ~GetUserDataResponse() override;
  explicit PROTOBUF_CONSTEXPR GetUserDataResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetUserDataResponse(const GetUserDataResponse& from);
  GetUserDataResponse(GetUserDataResponse&& from) noexcept
    : GetUserDataResponse() {
    *this = ::std::move(from);
  }

  inline GetUserDataResponse& operator=(const GetUserDataResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetUserDataResponse& operator=(GetUserDataResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetUserDataResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetUserDataResponse* internal_default_instance() {
    return reinterpret_cast<const GetUserDataResponse*>(
               &_GetUserDataResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(GetUserDataResponse& a, GetUserDataResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetUserDataResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetUserDataResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetUserDataResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetUserDataResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetUserDataResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetUserDataResponse& from) {
    GetUserDataResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetUserDataResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "GetUserDataResponse";
  }
  protected:
  explicit GetUserDataResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCarInfoArrFieldNumber = 1,
  };
  // repeated .CarInfo car_info_arr = 1;
  int car_info_arr_size() const;
  private:
  int _internal_car_info_arr_size() const;
  public:
  void clear_car_info_arr();
  ::CarInfo* mutable_car_info_arr(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CarInfo >*
      mutable_car_info_arr();
  private:
  const ::CarInfo& _internal_car_info_arr(int index) const;
  ::CarInfo* _internal_add_car_info_arr();
  public:
  const ::CarInfo& car_info_arr(int index) const;
  ::CarInfo* add_car_info_arr();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CarInfo >&
      car_info_arr() const;

  // @@protoc_insertion_point(class_scope:GetUserDataResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CarInfo > car_info_arr_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2eproto;
};
// -------------------------------------------------------------------

class AdminLoginRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:AdminLoginRequest) */ {
 public:
  inline AdminLoginRequest() : AdminLoginRequest(nullptr) {}
  ~AdminLoginRequest() override;
  explicit PROTOBUF_CONSTEXPR AdminLoginRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AdminLoginRequest(const AdminLoginRequest& from);
  AdminLoginRequest(AdminLoginRequest&& from) noexcept
    : AdminLoginRequest() {
    *this = ::std::move(from);
  }

  inline AdminLoginRequest& operator=(const AdminLoginRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline AdminLoginRequest& operator=(AdminLoginRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AdminLoginRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const AdminLoginRequest* internal_default_instance() {
    return reinterpret_cast<const AdminLoginRequest*>(
               &_AdminLoginRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(AdminLoginRequest& a, AdminLoginRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(AdminLoginRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AdminLoginRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AdminLoginRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AdminLoginRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AdminLoginRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AdminLoginRequest& from) {
    AdminLoginRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AdminLoginRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "AdminLoginRequest";
  }
  protected:
  explicit AdminLoginRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPasswordFieldNumber = 2,
    kPIdFieldNumber = 1,
  };
  // string password = 2;
  void clear_password();
  const std::string& password() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_password(ArgT0&& arg0, ArgT... args);
  std::string* mutable_password();
  PROTOBUF_NODISCARD std::string* release_password();
  void set_allocated_password(std::string* password);
  private:
  const std::string& _internal_password() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_password(const std::string& value);
  std::string* _internal_mutable_password();
  public:

  // int32 p_id = 1;
  void clear_p_id();
  int32_t p_id() const;
  void set_p_id(int32_t value);
  private:
  int32_t _internal_p_id() const;
  void _internal_set_p_id(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:AdminLoginRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr password_;
    int32_t p_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2eproto;
};
// -------------------------------------------------------------------

class AdminLoginResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:AdminLoginResponse) */ {
 public:
  inline AdminLoginResponse() : AdminLoginResponse(nullptr) {}
  ~AdminLoginResponse() override;
  explicit PROTOBUF_CONSTEXPR AdminLoginResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AdminLoginResponse(const AdminLoginResponse& from);
  AdminLoginResponse(AdminLoginResponse&& from) noexcept
    : AdminLoginResponse() {
    *this = ::std::move(from);
  }

  inline AdminLoginResponse& operator=(const AdminLoginResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline AdminLoginResponse& operator=(AdminLoginResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AdminLoginResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const AdminLoginResponse* internal_default_instance() {
    return reinterpret_cast<const AdminLoginResponse*>(
               &_AdminLoginResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(AdminLoginResponse& a, AdminLoginResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(AdminLoginResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AdminLoginResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AdminLoginResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AdminLoginResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AdminLoginResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AdminLoginResponse& from) {
    AdminLoginResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AdminLoginResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "AdminLoginResponse";
  }
  protected:
  explicit AdminLoginResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResultFieldNumber = 1,
    kCountFieldNumber = 2,
  };
  // .LoginResult result = 1;
  void clear_result();
  ::LoginResult result() const;
  void set_result(::LoginResult value);
  private:
  ::LoginResult _internal_result() const;
  void _internal_set_result(::LoginResult value);
  public:

  // int32 count = 2;
  void clear_count();
  int32_t count() const;
  void set_count(int32_t value);
  private:
  int32_t _internal_count() const;
  void _internal_set_count(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:AdminLoginResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int result_;
    int32_t count_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2eproto;
};
// -------------------------------------------------------------------

class AdminGetSpaceInfoRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:AdminGetSpaceInfoRequest) */ {
 public:
  inline AdminGetSpaceInfoRequest() : AdminGetSpaceInfoRequest(nullptr) {}
  ~AdminGetSpaceInfoRequest() override;
  explicit PROTOBUF_CONSTEXPR AdminGetSpaceInfoRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AdminGetSpaceInfoRequest(const AdminGetSpaceInfoRequest& from);
  AdminGetSpaceInfoRequest(AdminGetSpaceInfoRequest&& from) noexcept
    : AdminGetSpaceInfoRequest() {
    *this = ::std::move(from);
  }

  inline AdminGetSpaceInfoRequest& operator=(const AdminGetSpaceInfoRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline AdminGetSpaceInfoRequest& operator=(AdminGetSpaceInfoRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AdminGetSpaceInfoRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const AdminGetSpaceInfoRequest* internal_default_instance() {
    return reinterpret_cast<const AdminGetSpaceInfoRequest*>(
               &_AdminGetSpaceInfoRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(AdminGetSpaceInfoRequest& a, AdminGetSpaceInfoRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(AdminGetSpaceInfoRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AdminGetSpaceInfoRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AdminGetSpaceInfoRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AdminGetSpaceInfoRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AdminGetSpaceInfoRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AdminGetSpaceInfoRequest& from) {
    AdminGetSpaceInfoRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AdminGetSpaceInfoRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "AdminGetSpaceInfoRequest";
  }
  protected:
  explicit AdminGetSpaceInfoRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPIdFieldNumber = 1,
    kSIdFieldNumber = 2,
  };
  // int32 p_id = 1;
  void clear_p_id();
  int32_t p_id() const;
  void set_p_id(int32_t value);
  private:
  int32_t _internal_p_id() const;
  void _internal_set_p_id(int32_t value);
  public:

  // int32 s_id = 2;
  void clear_s_id();
  int32_t s_id() const;
  void set_s_id(int32_t value);
  private:
  int32_t _internal_s_id() const;
  void _internal_set_s_id(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:AdminGetSpaceInfoRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t p_id_;
    int32_t s_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2eproto;
};
// -------------------------------------------------------------------

class AdminGetSpaceInfoResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:AdminGetSpaceInfoResponse) */ {
 public:
  inline AdminGetSpaceInfoResponse() : AdminGetSpaceInfoResponse(nullptr) {}
  ~AdminGetSpaceInfoResponse() override;
  explicit PROTOBUF_CONSTEXPR AdminGetSpaceInfoResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AdminGetSpaceInfoResponse(const AdminGetSpaceInfoResponse& from);
  AdminGetSpaceInfoResponse(AdminGetSpaceInfoResponse&& from) noexcept
    : AdminGetSpaceInfoResponse() {
    *this = ::std::move(from);
  }

  inline AdminGetSpaceInfoResponse& operator=(const AdminGetSpaceInfoResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline AdminGetSpaceInfoResponse& operator=(AdminGetSpaceInfoResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AdminGetSpaceInfoResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const AdminGetSpaceInfoResponse* internal_default_instance() {
    return reinterpret_cast<const AdminGetSpaceInfoResponse*>(
               &_AdminGetSpaceInfoResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(AdminGetSpaceInfoResponse& a, AdminGetSpaceInfoResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(AdminGetSpaceInfoResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AdminGetSpaceInfoResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AdminGetSpaceInfoResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AdminGetSpaceInfoResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AdminGetSpaceInfoResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AdminGetSpaceInfoResponse& from) {
    AdminGetSpaceInfoResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AdminGetSpaceInfoResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "AdminGetSpaceInfoResponse";
  }
  protected:
  explicit AdminGetSpaceInfoResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLicenseFieldNumber = 2,
    kEntrytimeFieldNumber = 3,
    kIsUseFieldNumber = 1,
  };
  // string license = 2;
  void clear_license();
  const std::string& license() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_license(ArgT0&& arg0, ArgT... args);
  std::string* mutable_license();
  PROTOBUF_NODISCARD std::string* release_license();
  void set_allocated_license(std::string* license);
  private:
  const std::string& _internal_license() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_license(const std::string& value);
  std::string* _internal_mutable_license();
  public:

  // int64 entrytime = 3;
  void clear_entrytime();
  int64_t entrytime() const;
  void set_entrytime(int64_t value);
  private:
  int64_t _internal_entrytime() const;
  void _internal_set_entrytime(int64_t value);
  public:

  // bool is_use = 1;
  void clear_is_use();
  bool is_use() const;
  void set_is_use(bool value);
  private:
  bool _internal_is_use() const;
  void _internal_set_is_use(bool value);
  public:

  // @@protoc_insertion_point(class_scope:AdminGetSpaceInfoResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr license_;
    int64_t entrytime_;
    bool is_use_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// CarInfo

// int32 p_temperature = 1;
inline void CarInfo::clear_p_temperature() {
  _impl_.p_temperature_ = 0;
}
inline int32_t CarInfo::_internal_p_temperature() const {
  return _impl_.p_temperature_;
}
inline int32_t CarInfo::p_temperature() const {
  // @@protoc_insertion_point(field_get:CarInfo.p_temperature)
  return _internal_p_temperature();
}
inline void CarInfo::_internal_set_p_temperature(int32_t value) {
  
  _impl_.p_temperature_ = value;
}
inline void CarInfo::set_p_temperature(int32_t value) {
  _internal_set_p_temperature(value);
  // @@protoc_insertion_point(field_set:CarInfo.p_temperature)
}

// int32 p_humidity = 2;
inline void CarInfo::clear_p_humidity() {
  _impl_.p_humidity_ = 0;
}
inline int32_t CarInfo::_internal_p_humidity() const {
  return _impl_.p_humidity_;
}
inline int32_t CarInfo::p_humidity() const {
  // @@protoc_insertion_point(field_get:CarInfo.p_humidity)
  return _internal_p_humidity();
}
inline void CarInfo::_internal_set_p_humidity(int32_t value) {
  
  _impl_.p_humidity_ = value;
}
inline void CarInfo::set_p_humidity(int32_t value) {
  _internal_set_p_humidity(value);
  // @@protoc_insertion_point(field_set:CarInfo.p_humidity)
}

// int32 p_weather = 3;
inline void CarInfo::clear_p_weather() {
  _impl_.p_weather_ = 0;
}
inline int32_t CarInfo::_internal_p_weather() const {
  return _impl_.p_weather_;
}
inline int32_t CarInfo::p_weather() const {
  // @@protoc_insertion_point(field_get:CarInfo.p_weather)
  return _internal_p_weather();
}
inline void CarInfo::_internal_set_p_weather(int32_t value) {
  
  _impl_.p_weather_ = value;
}
inline void CarInfo::set_p_weather(int32_t value) {
  _internal_set_p_weather(value);
  // @@protoc_insertion_point(field_set:CarInfo.p_weather)
}

// string p_address = 4;
inline void CarInfo::clear_p_address() {
  _impl_.p_address_.ClearToEmpty();
}
inline const std::string& CarInfo::p_address() const {
  // @@protoc_insertion_point(field_get:CarInfo.p_address)
  return _internal_p_address();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CarInfo::set_p_address(ArgT0&& arg0, ArgT... args) {
 
 _impl_.p_address_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CarInfo.p_address)
}
inline std::string* CarInfo::mutable_p_address() {
  std::string* _s = _internal_mutable_p_address();
  // @@protoc_insertion_point(field_mutable:CarInfo.p_address)
  return _s;
}
inline const std::string& CarInfo::_internal_p_address() const {
  return _impl_.p_address_.Get();
}
inline void CarInfo::_internal_set_p_address(const std::string& value) {
  
  _impl_.p_address_.Set(value, GetArenaForAllocation());
}
inline std::string* CarInfo::_internal_mutable_p_address() {
  
  return _impl_.p_address_.Mutable(GetArenaForAllocation());
}
inline std::string* CarInfo::release_p_address() {
  // @@protoc_insertion_point(field_release:CarInfo.p_address)
  return _impl_.p_address_.Release();
}
inline void CarInfo::set_allocated_p_address(std::string* p_address) {
  if (p_address != nullptr) {
    
  } else {
    
  }
  _impl_.p_address_.SetAllocated(p_address, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.p_address_.IsDefault()) {
    _impl_.p_address_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CarInfo.p_address)
}

// int32 s_id = 5;
inline void CarInfo::clear_s_id() {
  _impl_.s_id_ = 0;
}
inline int32_t CarInfo::_internal_s_id() const {
  return _impl_.s_id_;
}
inline int32_t CarInfo::s_id() const {
  // @@protoc_insertion_point(field_get:CarInfo.s_id)
  return _internal_s_id();
}
inline void CarInfo::_internal_set_s_id(int32_t value) {
  
  _impl_.s_id_ = value;
}
inline void CarInfo::set_s_id(int32_t value) {
  _internal_set_s_id(value);
  // @@protoc_insertion_point(field_set:CarInfo.s_id)
}

// string s_data = 6;
inline void CarInfo::clear_s_data() {
  _impl_.s_data_.ClearToEmpty();
}
inline const std::string& CarInfo::s_data() const {
  // @@protoc_insertion_point(field_get:CarInfo.s_data)
  return _internal_s_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CarInfo::set_s_data(ArgT0&& arg0, ArgT... args) {
 
 _impl_.s_data_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CarInfo.s_data)
}
inline std::string* CarInfo::mutable_s_data() {
  std::string* _s = _internal_mutable_s_data();
  // @@protoc_insertion_point(field_mutable:CarInfo.s_data)
  return _s;
}
inline const std::string& CarInfo::_internal_s_data() const {
  return _impl_.s_data_.Get();
}
inline void CarInfo::_internal_set_s_data(const std::string& value) {
  
  _impl_.s_data_.Set(value, GetArenaForAllocation());
}
inline std::string* CarInfo::_internal_mutable_s_data() {
  
  return _impl_.s_data_.Mutable(GetArenaForAllocation());
}
inline std::string* CarInfo::release_s_data() {
  // @@protoc_insertion_point(field_release:CarInfo.s_data)
  return _impl_.s_data_.Release();
}
inline void CarInfo::set_allocated_s_data(std::string* s_data) {
  if (s_data != nullptr) {
    
  } else {
    
  }
  _impl_.s_data_.SetAllocated(s_data, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.s_data_.IsDefault()) {
    _impl_.s_data_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CarInfo.s_data)
}

// -------------------------------------------------------------------

// UserLoginRequest

// string username = 1;
inline void UserLoginRequest::clear_username() {
  _impl_.username_.ClearToEmpty();
}
inline const std::string& UserLoginRequest::username() const {
  // @@protoc_insertion_point(field_get:UserLoginRequest.username)
  return _internal_username();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UserLoginRequest::set_username(ArgT0&& arg0, ArgT... args) {
 
 _impl_.username_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:UserLoginRequest.username)
}
inline std::string* UserLoginRequest::mutable_username() {
  std::string* _s = _internal_mutable_username();
  // @@protoc_insertion_point(field_mutable:UserLoginRequest.username)
  return _s;
}
inline const std::string& UserLoginRequest::_internal_username() const {
  return _impl_.username_.Get();
}
inline void UserLoginRequest::_internal_set_username(const std::string& value) {
  
  _impl_.username_.Set(value, GetArenaForAllocation());
}
inline std::string* UserLoginRequest::_internal_mutable_username() {
  
  return _impl_.username_.Mutable(GetArenaForAllocation());
}
inline std::string* UserLoginRequest::release_username() {
  // @@protoc_insertion_point(field_release:UserLoginRequest.username)
  return _impl_.username_.Release();
}
inline void UserLoginRequest::set_allocated_username(std::string* username) {
  if (username != nullptr) {
    
  } else {
    
  }
  _impl_.username_.SetAllocated(username, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.username_.IsDefault()) {
    _impl_.username_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:UserLoginRequest.username)
}

// string password = 2;
inline void UserLoginRequest::clear_password() {
  _impl_.password_.ClearToEmpty();
}
inline const std::string& UserLoginRequest::password() const {
  // @@protoc_insertion_point(field_get:UserLoginRequest.password)
  return _internal_password();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UserLoginRequest::set_password(ArgT0&& arg0, ArgT... args) {
 
 _impl_.password_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:UserLoginRequest.password)
}
inline std::string* UserLoginRequest::mutable_password() {
  std::string* _s = _internal_mutable_password();
  // @@protoc_insertion_point(field_mutable:UserLoginRequest.password)
  return _s;
}
inline const std::string& UserLoginRequest::_internal_password() const {
  return _impl_.password_.Get();
}
inline void UserLoginRequest::_internal_set_password(const std::string& value) {
  
  _impl_.password_.Set(value, GetArenaForAllocation());
}
inline std::string* UserLoginRequest::_internal_mutable_password() {
  
  return _impl_.password_.Mutable(GetArenaForAllocation());
}
inline std::string* UserLoginRequest::release_password() {
  // @@protoc_insertion_point(field_release:UserLoginRequest.password)
  return _impl_.password_.Release();
}
inline void UserLoginRequest::set_allocated_password(std::string* password) {
  if (password != nullptr) {
    
  } else {
    
  }
  _impl_.password_.SetAllocated(password, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.password_.IsDefault()) {
    _impl_.password_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:UserLoginRequest.password)
}

// -------------------------------------------------------------------

// UserLoginResponse

// .LoginResult result = 1;
inline void UserLoginResponse::clear_result() {
  _impl_.result_ = 0;
}
inline ::LoginResult UserLoginResponse::_internal_result() const {
  return static_cast< ::LoginResult >(_impl_.result_);
}
inline ::LoginResult UserLoginResponse::result() const {
  // @@protoc_insertion_point(field_get:UserLoginResponse.result)
  return _internal_result();
}
inline void UserLoginResponse::_internal_set_result(::LoginResult value) {
  
  _impl_.result_ = value;
}
inline void UserLoginResponse::set_result(::LoginResult value) {
  _internal_set_result(value);
  // @@protoc_insertion_point(field_set:UserLoginResponse.result)
}

// int32 u_id = 2;
inline void UserLoginResponse::clear_u_id() {
  _impl_.u_id_ = 0;
}
inline int32_t UserLoginResponse::_internal_u_id() const {
  return _impl_.u_id_;
}
inline int32_t UserLoginResponse::u_id() const {
  // @@protoc_insertion_point(field_get:UserLoginResponse.u_id)
  return _internal_u_id();
}
inline void UserLoginResponse::_internal_set_u_id(int32_t value) {
  
  _impl_.u_id_ = value;
}
inline void UserLoginResponse::set_u_id(int32_t value) {
  _internal_set_u_id(value);
  // @@protoc_insertion_point(field_set:UserLoginResponse.u_id)
}

// -------------------------------------------------------------------

// UserRegistrationRequest

// string username = 1;
inline void UserRegistrationRequest::clear_username() {
  _impl_.username_.ClearToEmpty();
}
inline const std::string& UserRegistrationRequest::username() const {
  // @@protoc_insertion_point(field_get:UserRegistrationRequest.username)
  return _internal_username();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UserRegistrationRequest::set_username(ArgT0&& arg0, ArgT... args) {
 
 _impl_.username_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:UserRegistrationRequest.username)
}
inline std::string* UserRegistrationRequest::mutable_username() {
  std::string* _s = _internal_mutable_username();
  // @@protoc_insertion_point(field_mutable:UserRegistrationRequest.username)
  return _s;
}
inline const std::string& UserRegistrationRequest::_internal_username() const {
  return _impl_.username_.Get();
}
inline void UserRegistrationRequest::_internal_set_username(const std::string& value) {
  
  _impl_.username_.Set(value, GetArenaForAllocation());
}
inline std::string* UserRegistrationRequest::_internal_mutable_username() {
  
  return _impl_.username_.Mutable(GetArenaForAllocation());
}
inline std::string* UserRegistrationRequest::release_username() {
  // @@protoc_insertion_point(field_release:UserRegistrationRequest.username)
  return _impl_.username_.Release();
}
inline void UserRegistrationRequest::set_allocated_username(std::string* username) {
  if (username != nullptr) {
    
  } else {
    
  }
  _impl_.username_.SetAllocated(username, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.username_.IsDefault()) {
    _impl_.username_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:UserRegistrationRequest.username)
}

// string password = 2;
inline void UserRegistrationRequest::clear_password() {
  _impl_.password_.ClearToEmpty();
}
inline const std::string& UserRegistrationRequest::password() const {
  // @@protoc_insertion_point(field_get:UserRegistrationRequest.password)
  return _internal_password();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UserRegistrationRequest::set_password(ArgT0&& arg0, ArgT... args) {
 
 _impl_.password_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:UserRegistrationRequest.password)
}
inline std::string* UserRegistrationRequest::mutable_password() {
  std::string* _s = _internal_mutable_password();
  // @@protoc_insertion_point(field_mutable:UserRegistrationRequest.password)
  return _s;
}
inline const std::string& UserRegistrationRequest::_internal_password() const {
  return _impl_.password_.Get();
}
inline void UserRegistrationRequest::_internal_set_password(const std::string& value) {
  
  _impl_.password_.Set(value, GetArenaForAllocation());
}
inline std::string* UserRegistrationRequest::_internal_mutable_password() {
  
  return _impl_.password_.Mutable(GetArenaForAllocation());
}
inline std::string* UserRegistrationRequest::release_password() {
  // @@protoc_insertion_point(field_release:UserRegistrationRequest.password)
  return _impl_.password_.Release();
}
inline void UserRegistrationRequest::set_allocated_password(std::string* password) {
  if (password != nullptr) {
    
  } else {
    
  }
  _impl_.password_.SetAllocated(password, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.password_.IsDefault()) {
    _impl_.password_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:UserRegistrationRequest.password)
}

// -------------------------------------------------------------------

// UserRegistrationResponse

// .RegistrationResult result = 1;
inline void UserRegistrationResponse::clear_result() {
  _impl_.result_ = 0;
}
inline ::RegistrationResult UserRegistrationResponse::_internal_result() const {
  return static_cast< ::RegistrationResult >(_impl_.result_);
}
inline ::RegistrationResult UserRegistrationResponse::result() const {
  // @@protoc_insertion_point(field_get:UserRegistrationResponse.result)
  return _internal_result();
}
inline void UserRegistrationResponse::_internal_set_result(::RegistrationResult value) {
  
  _impl_.result_ = value;
}
inline void UserRegistrationResponse::set_result(::RegistrationResult value) {
  _internal_set_result(value);
  // @@protoc_insertion_point(field_set:UserRegistrationResponse.result)
}

// -------------------------------------------------------------------

// CarOperationRequest

// .CarOperation operation = 1;
inline void CarOperationRequest::clear_operation() {
  _impl_.operation_ = 0;
}
inline ::CarOperation CarOperationRequest::_internal_operation() const {
  return static_cast< ::CarOperation >(_impl_.operation_);
}
inline ::CarOperation CarOperationRequest::operation() const {
  // @@protoc_insertion_point(field_get:CarOperationRequest.operation)
  return _internal_operation();
}
inline void CarOperationRequest::_internal_set_operation(::CarOperation value) {
  
  _impl_.operation_ = value;
}
inline void CarOperationRequest::set_operation(::CarOperation value) {
  _internal_set_operation(value);
  // @@protoc_insertion_point(field_set:CarOperationRequest.operation)
}

// int32 u_id = 2;
inline void CarOperationRequest::clear_u_id() {
  _impl_.u_id_ = 0;
}
inline int32_t CarOperationRequest::_internal_u_id() const {
  return _impl_.u_id_;
}
inline int32_t CarOperationRequest::u_id() const {
  // @@protoc_insertion_point(field_get:CarOperationRequest.u_id)
  return _internal_u_id();
}
inline void CarOperationRequest::_internal_set_u_id(int32_t value) {
  
  _impl_.u_id_ = value;
}
inline void CarOperationRequest::set_u_id(int32_t value) {
  _internal_set_u_id(value);
  // @@protoc_insertion_point(field_set:CarOperationRequest.u_id)
}

// string license = 3;
inline void CarOperationRequest::clear_license() {
  _impl_.license_.ClearToEmpty();
}
inline const std::string& CarOperationRequest::license() const {
  // @@protoc_insertion_point(field_get:CarOperationRequest.license)
  return _internal_license();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CarOperationRequest::set_license(ArgT0&& arg0, ArgT... args) {
 
 _impl_.license_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CarOperationRequest.license)
}
inline std::string* CarOperationRequest::mutable_license() {
  std::string* _s = _internal_mutable_license();
  // @@protoc_insertion_point(field_mutable:CarOperationRequest.license)
  return _s;
}
inline const std::string& CarOperationRequest::_internal_license() const {
  return _impl_.license_.Get();
}
inline void CarOperationRequest::_internal_set_license(const std::string& value) {
  
  _impl_.license_.Set(value, GetArenaForAllocation());
}
inline std::string* CarOperationRequest::_internal_mutable_license() {
  
  return _impl_.license_.Mutable(GetArenaForAllocation());
}
inline std::string* CarOperationRequest::release_license() {
  // @@protoc_insertion_point(field_release:CarOperationRequest.license)
  return _impl_.license_.Release();
}
inline void CarOperationRequest::set_allocated_license(std::string* license) {
  if (license != nullptr) {
    
  } else {
    
  }
  _impl_.license_.SetAllocated(license, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.license_.IsDefault()) {
    _impl_.license_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CarOperationRequest.license)
}

// optional string new_license = 4;
inline bool CarOperationRequest::_internal_has_new_license() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CarOperationRequest::has_new_license() const {
  return _internal_has_new_license();
}
inline void CarOperationRequest::clear_new_license() {
  _impl_.new_license_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CarOperationRequest::new_license() const {
  // @@protoc_insertion_point(field_get:CarOperationRequest.new_license)
  return _internal_new_license();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CarOperationRequest::set_new_license(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.new_license_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CarOperationRequest.new_license)
}
inline std::string* CarOperationRequest::mutable_new_license() {
  std::string* _s = _internal_mutable_new_license();
  // @@protoc_insertion_point(field_mutable:CarOperationRequest.new_license)
  return _s;
}
inline const std::string& CarOperationRequest::_internal_new_license() const {
  return _impl_.new_license_.Get();
}
inline void CarOperationRequest::_internal_set_new_license(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.new_license_.Set(value, GetArenaForAllocation());
}
inline std::string* CarOperationRequest::_internal_mutable_new_license() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.new_license_.Mutable(GetArenaForAllocation());
}
inline std::string* CarOperationRequest::release_new_license() {
  // @@protoc_insertion_point(field_release:CarOperationRequest.new_license)
  if (!_internal_has_new_license()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.new_license_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.new_license_.IsDefault()) {
    _impl_.new_license_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CarOperationRequest::set_allocated_new_license(std::string* new_license) {
  if (new_license != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.new_license_.SetAllocated(new_license, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.new_license_.IsDefault()) {
    _impl_.new_license_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CarOperationRequest.new_license)
}

// -------------------------------------------------------------------

// CarOperationResponse

// .CarOperationResult result = 1;
inline void CarOperationResponse::clear_result() {
  _impl_.result_ = 0;
}
inline ::CarOperationResult CarOperationResponse::_internal_result() const {
  return static_cast< ::CarOperationResult >(_impl_.result_);
}
inline ::CarOperationResult CarOperationResponse::result() const {
  // @@protoc_insertion_point(field_get:CarOperationResponse.result)
  return _internal_result();
}
inline void CarOperationResponse::_internal_set_result(::CarOperationResult value) {
  
  _impl_.result_ = value;
}
inline void CarOperationResponse::set_result(::CarOperationResult value) {
  _internal_set_result(value);
  // @@protoc_insertion_point(field_set:CarOperationResponse.result)
}

// -------------------------------------------------------------------

// GetUserDataRequest

// int32 u_id = 1;
inline void GetUserDataRequest::clear_u_id() {
  _impl_.u_id_ = 0;
}
inline int32_t GetUserDataRequest::_internal_u_id() const {
  return _impl_.u_id_;
}
inline int32_t GetUserDataRequest::u_id() const {
  // @@protoc_insertion_point(field_get:GetUserDataRequest.u_id)
  return _internal_u_id();
}
inline void GetUserDataRequest::_internal_set_u_id(int32_t value) {
  
  _impl_.u_id_ = value;
}
inline void GetUserDataRequest::set_u_id(int32_t value) {
  _internal_set_u_id(value);
  // @@protoc_insertion_point(field_set:GetUserDataRequest.u_id)
}

// -------------------------------------------------------------------

// GetUserDataResponse

// repeated .CarInfo car_info_arr = 1;
inline int GetUserDataResponse::_internal_car_info_arr_size() const {
  return _impl_.car_info_arr_.size();
}
inline int GetUserDataResponse::car_info_arr_size() const {
  return _internal_car_info_arr_size();
}
inline void GetUserDataResponse::clear_car_info_arr() {
  _impl_.car_info_arr_.Clear();
}
inline ::CarInfo* GetUserDataResponse::mutable_car_info_arr(int index) {
  // @@protoc_insertion_point(field_mutable:GetUserDataResponse.car_info_arr)
  return _impl_.car_info_arr_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CarInfo >*
GetUserDataResponse::mutable_car_info_arr() {
  // @@protoc_insertion_point(field_mutable_list:GetUserDataResponse.car_info_arr)
  return &_impl_.car_info_arr_;
}
inline const ::CarInfo& GetUserDataResponse::_internal_car_info_arr(int index) const {
  return _impl_.car_info_arr_.Get(index);
}
inline const ::CarInfo& GetUserDataResponse::car_info_arr(int index) const {
  // @@protoc_insertion_point(field_get:GetUserDataResponse.car_info_arr)
  return _internal_car_info_arr(index);
}
inline ::CarInfo* GetUserDataResponse::_internal_add_car_info_arr() {
  return _impl_.car_info_arr_.Add();
}
inline ::CarInfo* GetUserDataResponse::add_car_info_arr() {
  ::CarInfo* _add = _internal_add_car_info_arr();
  // @@protoc_insertion_point(field_add:GetUserDataResponse.car_info_arr)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CarInfo >&
GetUserDataResponse::car_info_arr() const {
  // @@protoc_insertion_point(field_list:GetUserDataResponse.car_info_arr)
  return _impl_.car_info_arr_;
}

// -------------------------------------------------------------------

// AdminLoginRequest

// int32 p_id = 1;
inline void AdminLoginRequest::clear_p_id() {
  _impl_.p_id_ = 0;
}
inline int32_t AdminLoginRequest::_internal_p_id() const {
  return _impl_.p_id_;
}
inline int32_t AdminLoginRequest::p_id() const {
  // @@protoc_insertion_point(field_get:AdminLoginRequest.p_id)
  return _internal_p_id();
}
inline void AdminLoginRequest::_internal_set_p_id(int32_t value) {
  
  _impl_.p_id_ = value;
}
inline void AdminLoginRequest::set_p_id(int32_t value) {
  _internal_set_p_id(value);
  // @@protoc_insertion_point(field_set:AdminLoginRequest.p_id)
}

// string password = 2;
inline void AdminLoginRequest::clear_password() {
  _impl_.password_.ClearToEmpty();
}
inline const std::string& AdminLoginRequest::password() const {
  // @@protoc_insertion_point(field_get:AdminLoginRequest.password)
  return _internal_password();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AdminLoginRequest::set_password(ArgT0&& arg0, ArgT... args) {
 
 _impl_.password_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:AdminLoginRequest.password)
}
inline std::string* AdminLoginRequest::mutable_password() {
  std::string* _s = _internal_mutable_password();
  // @@protoc_insertion_point(field_mutable:AdminLoginRequest.password)
  return _s;
}
inline const std::string& AdminLoginRequest::_internal_password() const {
  return _impl_.password_.Get();
}
inline void AdminLoginRequest::_internal_set_password(const std::string& value) {
  
  _impl_.password_.Set(value, GetArenaForAllocation());
}
inline std::string* AdminLoginRequest::_internal_mutable_password() {
  
  return _impl_.password_.Mutable(GetArenaForAllocation());
}
inline std::string* AdminLoginRequest::release_password() {
  // @@protoc_insertion_point(field_release:AdminLoginRequest.password)
  return _impl_.password_.Release();
}
inline void AdminLoginRequest::set_allocated_password(std::string* password) {
  if (password != nullptr) {
    
  } else {
    
  }
  _impl_.password_.SetAllocated(password, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.password_.IsDefault()) {
    _impl_.password_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:AdminLoginRequest.password)
}

// -------------------------------------------------------------------

// AdminLoginResponse

// .LoginResult result = 1;
inline void AdminLoginResponse::clear_result() {
  _impl_.result_ = 0;
}
inline ::LoginResult AdminLoginResponse::_internal_result() const {
  return static_cast< ::LoginResult >(_impl_.result_);
}
inline ::LoginResult AdminLoginResponse::result() const {
  // @@protoc_insertion_point(field_get:AdminLoginResponse.result)
  return _internal_result();
}
inline void AdminLoginResponse::_internal_set_result(::LoginResult value) {
  
  _impl_.result_ = value;
}
inline void AdminLoginResponse::set_result(::LoginResult value) {
  _internal_set_result(value);
  // @@protoc_insertion_point(field_set:AdminLoginResponse.result)
}

// int32 count = 2;
inline void AdminLoginResponse::clear_count() {
  _impl_.count_ = 0;
}
inline int32_t AdminLoginResponse::_internal_count() const {
  return _impl_.count_;
}
inline int32_t AdminLoginResponse::count() const {
  // @@protoc_insertion_point(field_get:AdminLoginResponse.count)
  return _internal_count();
}
inline void AdminLoginResponse::_internal_set_count(int32_t value) {
  
  _impl_.count_ = value;
}
inline void AdminLoginResponse::set_count(int32_t value) {
  _internal_set_count(value);
  // @@protoc_insertion_point(field_set:AdminLoginResponse.count)
}

// -------------------------------------------------------------------

// AdminGetSpaceInfoRequest

// int32 p_id = 1;
inline void AdminGetSpaceInfoRequest::clear_p_id() {
  _impl_.p_id_ = 0;
}
inline int32_t AdminGetSpaceInfoRequest::_internal_p_id() const {
  return _impl_.p_id_;
}
inline int32_t AdminGetSpaceInfoRequest::p_id() const {
  // @@protoc_insertion_point(field_get:AdminGetSpaceInfoRequest.p_id)
  return _internal_p_id();
}
inline void AdminGetSpaceInfoRequest::_internal_set_p_id(int32_t value) {
  
  _impl_.p_id_ = value;
}
inline void AdminGetSpaceInfoRequest::set_p_id(int32_t value) {
  _internal_set_p_id(value);
  // @@protoc_insertion_point(field_set:AdminGetSpaceInfoRequest.p_id)
}

// int32 s_id = 2;
inline void AdminGetSpaceInfoRequest::clear_s_id() {
  _impl_.s_id_ = 0;
}
inline int32_t AdminGetSpaceInfoRequest::_internal_s_id() const {
  return _impl_.s_id_;
}
inline int32_t AdminGetSpaceInfoRequest::s_id() const {
  // @@protoc_insertion_point(field_get:AdminGetSpaceInfoRequest.s_id)
  return _internal_s_id();
}
inline void AdminGetSpaceInfoRequest::_internal_set_s_id(int32_t value) {
  
  _impl_.s_id_ = value;
}
inline void AdminGetSpaceInfoRequest::set_s_id(int32_t value) {
  _internal_set_s_id(value);
  // @@protoc_insertion_point(field_set:AdminGetSpaceInfoRequest.s_id)
}

// -------------------------------------------------------------------

// AdminGetSpaceInfoResponse

// bool is_use = 1;
inline void AdminGetSpaceInfoResponse::clear_is_use() {
  _impl_.is_use_ = false;
}
inline bool AdminGetSpaceInfoResponse::_internal_is_use() const {
  return _impl_.is_use_;
}
inline bool AdminGetSpaceInfoResponse::is_use() const {
  // @@protoc_insertion_point(field_get:AdminGetSpaceInfoResponse.is_use)
  return _internal_is_use();
}
inline void AdminGetSpaceInfoResponse::_internal_set_is_use(bool value) {
  
  _impl_.is_use_ = value;
}
inline void AdminGetSpaceInfoResponse::set_is_use(bool value) {
  _internal_set_is_use(value);
  // @@protoc_insertion_point(field_set:AdminGetSpaceInfoResponse.is_use)
}

// string license = 2;
inline void AdminGetSpaceInfoResponse::clear_license() {
  _impl_.license_.ClearToEmpty();
}
inline const std::string& AdminGetSpaceInfoResponse::license() const {
  // @@protoc_insertion_point(field_get:AdminGetSpaceInfoResponse.license)
  return _internal_license();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AdminGetSpaceInfoResponse::set_license(ArgT0&& arg0, ArgT... args) {
 
 _impl_.license_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:AdminGetSpaceInfoResponse.license)
}
inline std::string* AdminGetSpaceInfoResponse::mutable_license() {
  std::string* _s = _internal_mutable_license();
  // @@protoc_insertion_point(field_mutable:AdminGetSpaceInfoResponse.license)
  return _s;
}
inline const std::string& AdminGetSpaceInfoResponse::_internal_license() const {
  return _impl_.license_.Get();
}
inline void AdminGetSpaceInfoResponse::_internal_set_license(const std::string& value) {
  
  _impl_.license_.Set(value, GetArenaForAllocation());
}
inline std::string* AdminGetSpaceInfoResponse::_internal_mutable_license() {
  
  return _impl_.license_.Mutable(GetArenaForAllocation());
}
inline std::string* AdminGetSpaceInfoResponse::release_license() {
  // @@protoc_insertion_point(field_release:AdminGetSpaceInfoResponse.license)
  return _impl_.license_.Release();
}
inline void AdminGetSpaceInfoResponse::set_allocated_license(std::string* license) {
  if (license != nullptr) {
    
  } else {
    
  }
  _impl_.license_.SetAllocated(license, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.license_.IsDefault()) {
    _impl_.license_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:AdminGetSpaceInfoResponse.license)
}

// int64 entrytime = 3;
inline void AdminGetSpaceInfoResponse::clear_entrytime() {
  _impl_.entrytime_ = int64_t{0};
}
inline int64_t AdminGetSpaceInfoResponse::_internal_entrytime() const {
  return _impl_.entrytime_;
}
inline int64_t AdminGetSpaceInfoResponse::entrytime() const {
  // @@protoc_insertion_point(field_get:AdminGetSpaceInfoResponse.entrytime)
  return _internal_entrytime();
}
inline void AdminGetSpaceInfoResponse::_internal_set_entrytime(int64_t value) {
  
  _impl_.entrytime_ = value;
}
inline void AdminGetSpaceInfoResponse::set_entrytime(int64_t value) {
  _internal_set_entrytime(value);
  // @@protoc_insertion_point(field_set:AdminGetSpaceInfoResponse.entrytime)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::Alarm> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Alarm>() {
  return ::Alarm_descriptor();
}
template <> struct is_proto_enum< ::LoginResult> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::LoginResult>() {
  return ::LoginResult_descriptor();
}
template <> struct is_proto_enum< ::RegistrationResult> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::RegistrationResult>() {
  return ::RegistrationResult_descriptor();
}
template <> struct is_proto_enum< ::CarOperation> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::CarOperation>() {
  return ::CarOperation_descriptor();
}
template <> struct is_proto_enum< ::CarOperationResult> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::CarOperationResult>() {
  return ::CarOperationResult_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_service_2eproto
