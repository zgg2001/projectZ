// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: service.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_service_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_service_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_service_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_service_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_service_2eproto;
class AdminGetDataRequest;
struct AdminGetDataRequestDefaultTypeInternal;
extern AdminGetDataRequestDefaultTypeInternal _AdminGetDataRequest_default_instance_;
class AdminGetDataResponse;
struct AdminGetDataResponseDefaultTypeInternal;
extern AdminGetDataResponseDefaultTypeInternal _AdminGetDataResponse_default_instance_;
class AdminLoginRequest;
struct AdminLoginRequestDefaultTypeInternal;
extern AdminLoginRequestDefaultTypeInternal _AdminLoginRequest_default_instance_;
class AdminLoginResponse;
struct AdminLoginResponseDefaultTypeInternal;
extern AdminLoginResponseDefaultTypeInternal _AdminLoginResponse_default_instance_;
class CarInfo;
struct CarInfoDefaultTypeInternal;
extern CarInfoDefaultTypeInternal _CarInfo_default_instance_;
class CarOperationRequest;
struct CarOperationRequestDefaultTypeInternal;
extern CarOperationRequestDefaultTypeInternal _CarOperationRequest_default_instance_;
class CarOperationResponse;
struct CarOperationResponseDefaultTypeInternal;
extern CarOperationResponseDefaultTypeInternal _CarOperationResponse_default_instance_;
class GetUserDataRequest;
struct GetUserDataRequestDefaultTypeInternal;
extern GetUserDataRequestDefaultTypeInternal _GetUserDataRequest_default_instance_;
class GetUserDataResponse;
struct GetUserDataResponseDefaultTypeInternal;
extern GetUserDataResponseDefaultTypeInternal _GetUserDataResponse_default_instance_;
class LPCheckRequest;
struct LPCheckRequestDefaultTypeInternal;
extern LPCheckRequestDefaultTypeInternal _LPCheckRequest_default_instance_;
class LPCheckResponse;
struct LPCheckResponseDefaultTypeInternal;
extern LPCheckResponseDefaultTypeInternal _LPCheckResponse_default_instance_;
class ParkingInfo;
struct ParkingInfoDefaultTypeInternal;
extern ParkingInfoDefaultTypeInternal _ParkingInfo_default_instance_;
class ParkingSpaceInfo;
struct ParkingSpaceInfoDefaultTypeInternal;
extern ParkingSpaceInfoDefaultTypeInternal _ParkingSpaceInfo_default_instance_;
class UploadInfoRequest;
struct UploadInfoRequestDefaultTypeInternal;
extern UploadInfoRequestDefaultTypeInternal _UploadInfoRequest_default_instance_;
class UploadInfoResponse;
struct UploadInfoResponseDefaultTypeInternal;
extern UploadInfoResponseDefaultTypeInternal _UploadInfoResponse_default_instance_;
class UserLoginRequest;
struct UserLoginRequestDefaultTypeInternal;
extern UserLoginRequestDefaultTypeInternal _UserLoginRequest_default_instance_;
class UserLoginResponse;
struct UserLoginResponseDefaultTypeInternal;
extern UserLoginResponseDefaultTypeInternal _UserLoginResponse_default_instance_;
class UserRegistrationRequest;
struct UserRegistrationRequestDefaultTypeInternal;
extern UserRegistrationRequestDefaultTypeInternal _UserRegistrationRequest_default_instance_;
class UserRegistrationResponse;
struct UserRegistrationResponseDefaultTypeInternal;
extern UserRegistrationResponseDefaultTypeInternal _UserRegistrationResponse_default_instance_;
PROTOBUF_NAMESPACE_OPEN
template<> ::AdminGetDataRequest* Arena::CreateMaybeMessage<::AdminGetDataRequest>(Arena*);
template<> ::AdminGetDataResponse* Arena::CreateMaybeMessage<::AdminGetDataResponse>(Arena*);
template<> ::AdminLoginRequest* Arena::CreateMaybeMessage<::AdminLoginRequest>(Arena*);
template<> ::AdminLoginResponse* Arena::CreateMaybeMessage<::AdminLoginResponse>(Arena*);
template<> ::CarInfo* Arena::CreateMaybeMessage<::CarInfo>(Arena*);
template<> ::CarOperationRequest* Arena::CreateMaybeMessage<::CarOperationRequest>(Arena*);
template<> ::CarOperationResponse* Arena::CreateMaybeMessage<::CarOperationResponse>(Arena*);
template<> ::GetUserDataRequest* Arena::CreateMaybeMessage<::GetUserDataRequest>(Arena*);
template<> ::GetUserDataResponse* Arena::CreateMaybeMessage<::GetUserDataResponse>(Arena*);
template<> ::LPCheckRequest* Arena::CreateMaybeMessage<::LPCheckRequest>(Arena*);
template<> ::LPCheckResponse* Arena::CreateMaybeMessage<::LPCheckResponse>(Arena*);
template<> ::ParkingInfo* Arena::CreateMaybeMessage<::ParkingInfo>(Arena*);
template<> ::ParkingSpaceInfo* Arena::CreateMaybeMessage<::ParkingSpaceInfo>(Arena*);
template<> ::UploadInfoRequest* Arena::CreateMaybeMessage<::UploadInfoRequest>(Arena*);
template<> ::UploadInfoResponse* Arena::CreateMaybeMessage<::UploadInfoResponse>(Arena*);
template<> ::UserLoginRequest* Arena::CreateMaybeMessage<::UserLoginRequest>(Arena*);
template<> ::UserLoginResponse* Arena::CreateMaybeMessage<::UserLoginResponse>(Arena*);
template<> ::UserRegistrationRequest* Arena::CreateMaybeMessage<::UserRegistrationRequest>(Arena*);
template<> ::UserRegistrationResponse* Arena::CreateMaybeMessage<::UserRegistrationResponse>(Arena*);
PROTOBUF_NAMESPACE_CLOSE

enum Alarm : int {
  ALARM_NO = 0,
  ALARM_FIRE = 1,
  ALARM_GAS = 2,
  ALARM_FIRE_AND_GAS = 3,
  Alarm_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  Alarm_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool Alarm_IsValid(int value);
constexpr Alarm Alarm_MIN = ALARM_NO;
constexpr Alarm Alarm_MAX = ALARM_FIRE_AND_GAS;
constexpr int Alarm_ARRAYSIZE = Alarm_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Alarm_descriptor();
template<typename T>
inline const std::string& Alarm_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Alarm>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Alarm_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Alarm_descriptor(), enum_t_value);
}
inline bool Alarm_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Alarm* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Alarm>(
    Alarm_descriptor(), name, value);
}
enum LoginResult : int {
  LOGIN_SUCCESS = 0,
  LOGIN_FAIL_NOT_EXIST = 1,
  LOGIN_FAIL_WRONG_PASSWORD = 2,
  LoginResult_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  LoginResult_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool LoginResult_IsValid(int value);
constexpr LoginResult LoginResult_MIN = LOGIN_SUCCESS;
constexpr LoginResult LoginResult_MAX = LOGIN_FAIL_WRONG_PASSWORD;
constexpr int LoginResult_ARRAYSIZE = LoginResult_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* LoginResult_descriptor();
template<typename T>
inline const std::string& LoginResult_Name(T enum_t_value) {
  static_assert(::std::is_same<T, LoginResult>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function LoginResult_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    LoginResult_descriptor(), enum_t_value);
}
inline bool LoginResult_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, LoginResult* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<LoginResult>(
    LoginResult_descriptor(), name, value);
}
enum RegistrationResult : int {
  REGISTRATION_SUCCESS = 0,
  REGISTRATION_FAIL_ALREADY_EXIST = 1,
  RegistrationResult_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  RegistrationResult_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool RegistrationResult_IsValid(int value);
constexpr RegistrationResult RegistrationResult_MIN = REGISTRATION_SUCCESS;
constexpr RegistrationResult RegistrationResult_MAX = REGISTRATION_FAIL_ALREADY_EXIST;
constexpr int RegistrationResult_ARRAYSIZE = RegistrationResult_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* RegistrationResult_descriptor();
template<typename T>
inline const std::string& RegistrationResult_Name(T enum_t_value) {
  static_assert(::std::is_same<T, RegistrationResult>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function RegistrationResult_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    RegistrationResult_descriptor(), enum_t_value);
}
inline bool RegistrationResult_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, RegistrationResult* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<RegistrationResult>(
    RegistrationResult_descriptor(), name, value);
}
enum CarOperation : int {
  OPERATION_ADD = 0,
  OPERATION_DELETE = 1,
  OPERATION_CHANGE = 2,
  CarOperation_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  CarOperation_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool CarOperation_IsValid(int value);
constexpr CarOperation CarOperation_MIN = OPERATION_ADD;
constexpr CarOperation CarOperation_MAX = OPERATION_CHANGE;
constexpr int CarOperation_ARRAYSIZE = CarOperation_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* CarOperation_descriptor();
template<typename T>
inline const std::string& CarOperation_Name(T enum_t_value) {
  static_assert(::std::is_same<T, CarOperation>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function CarOperation_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    CarOperation_descriptor(), enum_t_value);
}
inline bool CarOperation_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, CarOperation* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<CarOperation>(
    CarOperation_descriptor(), name, value);
}
enum CarOperationResult : int {
  OPERATION_ADD_SUCCESS = 0,
  OPERATION_ADD_FAIL_ALREADY_EXIST = 1,
  OPERATION_ADD_FAIL_USER_NOT_EXIST = 2,
  OPERATION_DELETE_SUCCESS = 3,
  OPERATION_DELETE_FAIL_ENTERED = 4,
  OPERATION_DELETE_FAIL_NOT_EXIST = 5,
  OPERATION_DELETE_FAIL_USER_NOT_EXIST = 6,
  OPERATION_CHANGE_SUCCESS = 7,
  OPERATION_CHANGE_FAIL_ENTERED = 8,
  OPERATION_CHANGE_FAIL_NOT_EXIST = 9,
  OPERATION_CHANGE_FAIL_USER_NOT_EXIST = 10,
  CarOperationResult_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  CarOperationResult_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool CarOperationResult_IsValid(int value);
constexpr CarOperationResult CarOperationResult_MIN = OPERATION_ADD_SUCCESS;
constexpr CarOperationResult CarOperationResult_MAX = OPERATION_CHANGE_FAIL_USER_NOT_EXIST;
constexpr int CarOperationResult_ARRAYSIZE = CarOperationResult_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* CarOperationResult_descriptor();
template<typename T>
inline const std::string& CarOperationResult_Name(T enum_t_value) {
  static_assert(::std::is_same<T, CarOperationResult>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function CarOperationResult_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    CarOperationResult_descriptor(), enum_t_value);
}
inline bool CarOperationResult_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, CarOperationResult* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<CarOperationResult>(
    CarOperationResult_descriptor(), name, value);
}
// ===================================================================

class ParkingInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ParkingInfo) */ {
 public:
  inline ParkingInfo() : ParkingInfo(nullptr) {}
  ~ParkingInfo() override;
  explicit PROTOBUF_CONSTEXPR ParkingInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ParkingInfo(const ParkingInfo& from);
  ParkingInfo(ParkingInfo&& from) noexcept
    : ParkingInfo() {
    *this = ::std::move(from);
  }

  inline ParkingInfo& operator=(const ParkingInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline ParkingInfo& operator=(ParkingInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ParkingInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const ParkingInfo* internal_default_instance() {
    return reinterpret_cast<const ParkingInfo*>(
               &_ParkingInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(ParkingInfo& a, ParkingInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(ParkingInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ParkingInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ParkingInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ParkingInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ParkingInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ParkingInfo& from) {
    ParkingInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ParkingInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ParkingInfo";
  }
  protected:
  explicit ParkingInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPIdFieldNumber = 1,
    kTemperatureFieldNumber = 2,
    kHumidityFieldNumber = 3,
    kWeatherFieldNumber = 4,
  };
  // int32 p_id = 1;
  void clear_p_id();
  int32_t p_id() const;
  void set_p_id(int32_t value);
  private:
  int32_t _internal_p_id() const;
  void _internal_set_p_id(int32_t value);
  public:

  // int32 temperature = 2;
  void clear_temperature();
  int32_t temperature() const;
  void set_temperature(int32_t value);
  private:
  int32_t _internal_temperature() const;
  void _internal_set_temperature(int32_t value);
  public:

  // int32 humidity = 3;
  void clear_humidity();
  int32_t humidity() const;
  void set_humidity(int32_t value);
  private:
  int32_t _internal_humidity() const;
  void _internal_set_humidity(int32_t value);
  public:

  // int32 weather = 4;
  void clear_weather();
  int32_t weather() const;
  void set_weather(int32_t value);
  private:
  int32_t _internal_weather() const;
  void _internal_set_weather(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:ParkingInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t p_id_;
    int32_t temperature_;
    int32_t humidity_;
    int32_t weather_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2eproto;
};
// -------------------------------------------------------------------

class ParkingSpaceInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ParkingSpaceInfo) */ {
 public:
  inline ParkingSpaceInfo() : ParkingSpaceInfo(nullptr) {}
  ~ParkingSpaceInfo() override;
  explicit PROTOBUF_CONSTEXPR ParkingSpaceInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ParkingSpaceInfo(const ParkingSpaceInfo& from);
  ParkingSpaceInfo(ParkingSpaceInfo&& from) noexcept
    : ParkingSpaceInfo() {
    *this = ::std::move(from);
  }

  inline ParkingSpaceInfo& operator=(const ParkingSpaceInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline ParkingSpaceInfo& operator=(ParkingSpaceInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ParkingSpaceInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const ParkingSpaceInfo* internal_default_instance() {
    return reinterpret_cast<const ParkingSpaceInfo*>(
               &_ParkingSpaceInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(ParkingSpaceInfo& a, ParkingSpaceInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(ParkingSpaceInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ParkingSpaceInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ParkingSpaceInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ParkingSpaceInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ParkingSpaceInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ParkingSpaceInfo& from) {
    ParkingSpaceInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ParkingSpaceInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ParkingSpaceInfo";
  }
  protected:
  explicit ParkingSpaceInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSIdFieldNumber = 1,
    kTemperatureFieldNumber = 2,
    kHumidityFieldNumber = 3,
    kAlarmFieldNumber = 4,
  };
  // int32 s_id = 1;
  void clear_s_id();
  int32_t s_id() const;
  void set_s_id(int32_t value);
  private:
  int32_t _internal_s_id() const;
  void _internal_set_s_id(int32_t value);
  public:

  // int32 temperature = 2;
  void clear_temperature();
  int32_t temperature() const;
  void set_temperature(int32_t value);
  private:
  int32_t _internal_temperature() const;
  void _internal_set_temperature(int32_t value);
  public:

  // int32 humidity = 3;
  void clear_humidity();
  int32_t humidity() const;
  void set_humidity(int32_t value);
  private:
  int32_t _internal_humidity() const;
  void _internal_set_humidity(int32_t value);
  public:

  // .Alarm alarm = 4;
  void clear_alarm();
  ::Alarm alarm() const;
  void set_alarm(::Alarm value);
  private:
  ::Alarm _internal_alarm() const;
  void _internal_set_alarm(::Alarm value);
  public:

  // @@protoc_insertion_point(class_scope:ParkingSpaceInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t s_id_;
    int32_t temperature_;
    int32_t humidity_;
    int alarm_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2eproto;
};
// -------------------------------------------------------------------

class CarInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CarInfo) */ {
 public:
  inline CarInfo() : CarInfo(nullptr) {}
  ~CarInfo() override;
  explicit PROTOBUF_CONSTEXPR CarInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CarInfo(const CarInfo& from);
  CarInfo(CarInfo&& from) noexcept
    : CarInfo() {
    *this = ::std::move(from);
  }

  inline CarInfo& operator=(const CarInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline CarInfo& operator=(CarInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CarInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const CarInfo* internal_default_instance() {
    return reinterpret_cast<const CarInfo*>(
               &_CarInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(CarInfo& a, CarInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(CarInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CarInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CarInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CarInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CarInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CarInfo& from) {
    CarInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CarInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CarInfo";
  }
  protected:
  explicit CarInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPAddressFieldNumber = 4,
    kPTemperatureFieldNumber = 1,
    kPHumidityFieldNumber = 2,
    kPWeatherFieldNumber = 3,
    kSIdFieldNumber = 5,
    kSTemperatureFieldNumber = 6,
    kSHumidityFieldNumber = 7,
    kSAlarmFieldNumber = 8,
  };
  // string p_address = 4;
  void clear_p_address();
  const std::string& p_address() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_p_address(ArgT0&& arg0, ArgT... args);
  std::string* mutable_p_address();
  PROTOBUF_NODISCARD std::string* release_p_address();
  void set_allocated_p_address(std::string* p_address);
  private:
  const std::string& _internal_p_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_p_address(const std::string& value);
  std::string* _internal_mutable_p_address();
  public:

  // int32 p_temperature = 1;
  void clear_p_temperature();
  int32_t p_temperature() const;
  void set_p_temperature(int32_t value);
  private:
  int32_t _internal_p_temperature() const;
  void _internal_set_p_temperature(int32_t value);
  public:

  // int32 p_humidity = 2;
  void clear_p_humidity();
  int32_t p_humidity() const;
  void set_p_humidity(int32_t value);
  private:
  int32_t _internal_p_humidity() const;
  void _internal_set_p_humidity(int32_t value);
  public:

  // int32 p_weather = 3;
  void clear_p_weather();
  int32_t p_weather() const;
  void set_p_weather(int32_t value);
  private:
  int32_t _internal_p_weather() const;
  void _internal_set_p_weather(int32_t value);
  public:

  // int32 s_id = 5;
  void clear_s_id();
  int32_t s_id() const;
  void set_s_id(int32_t value);
  private:
  int32_t _internal_s_id() const;
  void _internal_set_s_id(int32_t value);
  public:

  // int32 s_temperature = 6;
  void clear_s_temperature();
  int32_t s_temperature() const;
  void set_s_temperature(int32_t value);
  private:
  int32_t _internal_s_temperature() const;
  void _internal_set_s_temperature(int32_t value);
  public:

  // int32 s_humidity = 7;
  void clear_s_humidity();
  int32_t s_humidity() const;
  void set_s_humidity(int32_t value);
  private:
  int32_t _internal_s_humidity() const;
  void _internal_set_s_humidity(int32_t value);
  public:

  // .Alarm s_alarm = 8;
  void clear_s_alarm();
  ::Alarm s_alarm() const;
  void set_s_alarm(::Alarm value);
  private:
  ::Alarm _internal_s_alarm() const;
  void _internal_set_s_alarm(::Alarm value);
  public:

  // @@protoc_insertion_point(class_scope:CarInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr p_address_;
    int32_t p_temperature_;
    int32_t p_humidity_;
    int32_t p_weather_;
    int32_t s_id_;
    int32_t s_temperature_;
    int32_t s_humidity_;
    int s_alarm_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2eproto;
};
// -------------------------------------------------------------------

class LPCheckRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:LPCheckRequest) */ {
 public:
  inline LPCheckRequest() : LPCheckRequest(nullptr) {}
  ~LPCheckRequest() override;
  explicit PROTOBUF_CONSTEXPR LPCheckRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LPCheckRequest(const LPCheckRequest& from);
  LPCheckRequest(LPCheckRequest&& from) noexcept
    : LPCheckRequest() {
    *this = ::std::move(from);
  }

  inline LPCheckRequest& operator=(const LPCheckRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline LPCheckRequest& operator=(LPCheckRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LPCheckRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const LPCheckRequest* internal_default_instance() {
    return reinterpret_cast<const LPCheckRequest*>(
               &_LPCheckRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(LPCheckRequest& a, LPCheckRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(LPCheckRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LPCheckRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LPCheckRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LPCheckRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LPCheckRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LPCheckRequest& from) {
    LPCheckRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LPCheckRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "LPCheckRequest";
  }
  protected:
  explicit LPCheckRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLicenseFieldNumber = 4,
    kModelFieldNumber = 1,
    kParkingIdFieldNumber = 2,
    kParkingSpaceIdFieldNumber = 3,
  };
  // string license = 4;
  void clear_license();
  const std::string& license() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_license(ArgT0&& arg0, ArgT... args);
  std::string* mutable_license();
  PROTOBUF_NODISCARD std::string* release_license();
  void set_allocated_license(std::string* license);
  private:
  const std::string& _internal_license() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_license(const std::string& value);
  std::string* _internal_mutable_license();
  public:

  // int32 model = 1;
  void clear_model();
  int32_t model() const;
  void set_model(int32_t value);
  private:
  int32_t _internal_model() const;
  void _internal_set_model(int32_t value);
  public:

  // int32 parking_id = 2;
  void clear_parking_id();
  int32_t parking_id() const;
  void set_parking_id(int32_t value);
  private:
  int32_t _internal_parking_id() const;
  void _internal_set_parking_id(int32_t value);
  public:

  // int32 parking_space_id = 3;
  void clear_parking_space_id();
  int32_t parking_space_id() const;
  void set_parking_space_id(int32_t value);
  private:
  int32_t _internal_parking_space_id() const;
  void _internal_set_parking_space_id(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:LPCheckRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr license_;
    int32_t model_;
    int32_t parking_id_;
    int32_t parking_space_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2eproto;
};
// -------------------------------------------------------------------

class LPCheckResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:LPCheckResponse) */ {
 public:
  inline LPCheckResponse() : LPCheckResponse(nullptr) {}
  ~LPCheckResponse() override;
  explicit PROTOBUF_CONSTEXPR LPCheckResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LPCheckResponse(const LPCheckResponse& from);
  LPCheckResponse(LPCheckResponse&& from) noexcept
    : LPCheckResponse() {
    *this = ::std::move(from);
  }

  inline LPCheckResponse& operator=(const LPCheckResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline LPCheckResponse& operator=(LPCheckResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LPCheckResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const LPCheckResponse* internal_default_instance() {
    return reinterpret_cast<const LPCheckResponse*>(
               &_LPCheckResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(LPCheckResponse& a, LPCheckResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(LPCheckResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LPCheckResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LPCheckResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LPCheckResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LPCheckResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LPCheckResponse& from) {
    LPCheckResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LPCheckResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "LPCheckResponse";
  }
  protected:
  explicit LPCheckResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResultFieldNumber = 1,
    kBalanceFieldNumber = 2,
  };
  // bool result = 1;
  void clear_result();
  bool result() const;
  void set_result(bool value);
  private:
  bool _internal_result() const;
  void _internal_set_result(bool value);
  public:

  // int32 balance = 2;
  void clear_balance();
  int32_t balance() const;
  void set_balance(int32_t value);
  private:
  int32_t _internal_balance() const;
  void _internal_set_balance(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:LPCheckResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    bool result_;
    int32_t balance_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2eproto;
};
// -------------------------------------------------------------------

class UploadInfoRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:UploadInfoRequest) */ {
 public:
  inline UploadInfoRequest() : UploadInfoRequest(nullptr) {}
  ~UploadInfoRequest() override;
  explicit PROTOBUF_CONSTEXPR UploadInfoRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UploadInfoRequest(const UploadInfoRequest& from);
  UploadInfoRequest(UploadInfoRequest&& from) noexcept
    : UploadInfoRequest() {
    *this = ::std::move(from);
  }

  inline UploadInfoRequest& operator=(const UploadInfoRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline UploadInfoRequest& operator=(UploadInfoRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UploadInfoRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const UploadInfoRequest* internal_default_instance() {
    return reinterpret_cast<const UploadInfoRequest*>(
               &_UploadInfoRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(UploadInfoRequest& a, UploadInfoRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(UploadInfoRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UploadInfoRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UploadInfoRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UploadInfoRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UploadInfoRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UploadInfoRequest& from) {
    UploadInfoRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UploadInfoRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "UploadInfoRequest";
  }
  protected:
  explicit UploadInfoRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSInfoArrFieldNumber = 2,
    kPInfoFieldNumber = 1,
  };
  // repeated .ParkingSpaceInfo s_info_arr = 2;
  int s_info_arr_size() const;
  private:
  int _internal_s_info_arr_size() const;
  public:
  void clear_s_info_arr();
  ::ParkingSpaceInfo* mutable_s_info_arr(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ParkingSpaceInfo >*
      mutable_s_info_arr();
  private:
  const ::ParkingSpaceInfo& _internal_s_info_arr(int index) const;
  ::ParkingSpaceInfo* _internal_add_s_info_arr();
  public:
  const ::ParkingSpaceInfo& s_info_arr(int index) const;
  ::ParkingSpaceInfo* add_s_info_arr();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ParkingSpaceInfo >&
      s_info_arr() const;

  // .ParkingInfo p_info = 1;
  bool has_p_info() const;
  private:
  bool _internal_has_p_info() const;
  public:
  void clear_p_info();
  const ::ParkingInfo& p_info() const;
  PROTOBUF_NODISCARD ::ParkingInfo* release_p_info();
  ::ParkingInfo* mutable_p_info();
  void set_allocated_p_info(::ParkingInfo* p_info);
  private:
  const ::ParkingInfo& _internal_p_info() const;
  ::ParkingInfo* _internal_mutable_p_info();
  public:
  void unsafe_arena_set_allocated_p_info(
      ::ParkingInfo* p_info);
  ::ParkingInfo* unsafe_arena_release_p_info();

  // @@protoc_insertion_point(class_scope:UploadInfoRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ParkingSpaceInfo > s_info_arr_;
    ::ParkingInfo* p_info_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2eproto;
};
// -------------------------------------------------------------------

class UploadInfoResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:UploadInfoResponse) */ {
 public:
  inline UploadInfoResponse() : UploadInfoResponse(nullptr) {}
  ~UploadInfoResponse() override;
  explicit PROTOBUF_CONSTEXPR UploadInfoResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UploadInfoResponse(const UploadInfoResponse& from);
  UploadInfoResponse(UploadInfoResponse&& from) noexcept
    : UploadInfoResponse() {
    *this = ::std::move(from);
  }

  inline UploadInfoResponse& operator=(const UploadInfoResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline UploadInfoResponse& operator=(UploadInfoResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UploadInfoResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const UploadInfoResponse* internal_default_instance() {
    return reinterpret_cast<const UploadInfoResponse*>(
               &_UploadInfoResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(UploadInfoResponse& a, UploadInfoResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(UploadInfoResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UploadInfoResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UploadInfoResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UploadInfoResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UploadInfoResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UploadInfoResponse& from) {
    UploadInfoResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UploadInfoResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "UploadInfoResponse";
  }
  protected:
  explicit UploadInfoResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResultFieldNumber = 1,
  };
  // int32 result = 1;
  void clear_result();
  int32_t result() const;
  void set_result(int32_t value);
  private:
  int32_t _internal_result() const;
  void _internal_set_result(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:UploadInfoResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t result_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2eproto;
};
// -------------------------------------------------------------------

class UserLoginRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:UserLoginRequest) */ {
 public:
  inline UserLoginRequest() : UserLoginRequest(nullptr) {}
  ~UserLoginRequest() override;
  explicit PROTOBUF_CONSTEXPR UserLoginRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UserLoginRequest(const UserLoginRequest& from);
  UserLoginRequest(UserLoginRequest&& from) noexcept
    : UserLoginRequest() {
    *this = ::std::move(from);
  }

  inline UserLoginRequest& operator=(const UserLoginRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline UserLoginRequest& operator=(UserLoginRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UserLoginRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const UserLoginRequest* internal_default_instance() {
    return reinterpret_cast<const UserLoginRequest*>(
               &_UserLoginRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(UserLoginRequest& a, UserLoginRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(UserLoginRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UserLoginRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UserLoginRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UserLoginRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UserLoginRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UserLoginRequest& from) {
    UserLoginRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UserLoginRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "UserLoginRequest";
  }
  protected:
  explicit UserLoginRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUsernameFieldNumber = 1,
    kPasswordFieldNumber = 2,
  };
  // string username = 1;
  void clear_username();
  const std::string& username() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_username(ArgT0&& arg0, ArgT... args);
  std::string* mutable_username();
  PROTOBUF_NODISCARD std::string* release_username();
  void set_allocated_username(std::string* username);
  private:
  const std::string& _internal_username() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_username(const std::string& value);
  std::string* _internal_mutable_username();
  public:

  // string password = 2;
  void clear_password();
  const std::string& password() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_password(ArgT0&& arg0, ArgT... args);
  std::string* mutable_password();
  PROTOBUF_NODISCARD std::string* release_password();
  void set_allocated_password(std::string* password);
  private:
  const std::string& _internal_password() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_password(const std::string& value);
  std::string* _internal_mutable_password();
  public:

  // @@protoc_insertion_point(class_scope:UserLoginRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr username_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr password_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2eproto;
};
// -------------------------------------------------------------------

class UserLoginResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:UserLoginResponse) */ {
 public:
  inline UserLoginResponse() : UserLoginResponse(nullptr) {}
  ~UserLoginResponse() override;
  explicit PROTOBUF_CONSTEXPR UserLoginResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UserLoginResponse(const UserLoginResponse& from);
  UserLoginResponse(UserLoginResponse&& from) noexcept
    : UserLoginResponse() {
    *this = ::std::move(from);
  }

  inline UserLoginResponse& operator=(const UserLoginResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline UserLoginResponse& operator=(UserLoginResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UserLoginResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const UserLoginResponse* internal_default_instance() {
    return reinterpret_cast<const UserLoginResponse*>(
               &_UserLoginResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(UserLoginResponse& a, UserLoginResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(UserLoginResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UserLoginResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UserLoginResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UserLoginResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UserLoginResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UserLoginResponse& from) {
    UserLoginResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UserLoginResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "UserLoginResponse";
  }
  protected:
  explicit UserLoginResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResultFieldNumber = 1,
    kUIdFieldNumber = 2,
  };
  // .LoginResult result = 1;
  void clear_result();
  ::LoginResult result() const;
  void set_result(::LoginResult value);
  private:
  ::LoginResult _internal_result() const;
  void _internal_set_result(::LoginResult value);
  public:

  // int32 u_id = 2;
  void clear_u_id();
  int32_t u_id() const;
  void set_u_id(int32_t value);
  private:
  int32_t _internal_u_id() const;
  void _internal_set_u_id(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:UserLoginResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int result_;
    int32_t u_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2eproto;
};
// -------------------------------------------------------------------

class UserRegistrationRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:UserRegistrationRequest) */ {
 public:
  inline UserRegistrationRequest() : UserRegistrationRequest(nullptr) {}
  ~UserRegistrationRequest() override;
  explicit PROTOBUF_CONSTEXPR UserRegistrationRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UserRegistrationRequest(const UserRegistrationRequest& from);
  UserRegistrationRequest(UserRegistrationRequest&& from) noexcept
    : UserRegistrationRequest() {
    *this = ::std::move(from);
  }

  inline UserRegistrationRequest& operator=(const UserRegistrationRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline UserRegistrationRequest& operator=(UserRegistrationRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UserRegistrationRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const UserRegistrationRequest* internal_default_instance() {
    return reinterpret_cast<const UserRegistrationRequest*>(
               &_UserRegistrationRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(UserRegistrationRequest& a, UserRegistrationRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(UserRegistrationRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UserRegistrationRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UserRegistrationRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UserRegistrationRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UserRegistrationRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UserRegistrationRequest& from) {
    UserRegistrationRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UserRegistrationRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "UserRegistrationRequest";
  }
  protected:
  explicit UserRegistrationRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUsernameFieldNumber = 1,
    kPasswordFieldNumber = 2,
  };
  // string username = 1;
  void clear_username();
  const std::string& username() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_username(ArgT0&& arg0, ArgT... args);
  std::string* mutable_username();
  PROTOBUF_NODISCARD std::string* release_username();
  void set_allocated_username(std::string* username);
  private:
  const std::string& _internal_username() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_username(const std::string& value);
  std::string* _internal_mutable_username();
  public:

  // string password = 2;
  void clear_password();
  const std::string& password() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_password(ArgT0&& arg0, ArgT... args);
  std::string* mutable_password();
  PROTOBUF_NODISCARD std::string* release_password();
  void set_allocated_password(std::string* password);
  private:
  const std::string& _internal_password() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_password(const std::string& value);
  std::string* _internal_mutable_password();
  public:

  // @@protoc_insertion_point(class_scope:UserRegistrationRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr username_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr password_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2eproto;
};
// -------------------------------------------------------------------

class UserRegistrationResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:UserRegistrationResponse) */ {
 public:
  inline UserRegistrationResponse() : UserRegistrationResponse(nullptr) {}
  ~UserRegistrationResponse() override;
  explicit PROTOBUF_CONSTEXPR UserRegistrationResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UserRegistrationResponse(const UserRegistrationResponse& from);
  UserRegistrationResponse(UserRegistrationResponse&& from) noexcept
    : UserRegistrationResponse() {
    *this = ::std::move(from);
  }

  inline UserRegistrationResponse& operator=(const UserRegistrationResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline UserRegistrationResponse& operator=(UserRegistrationResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UserRegistrationResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const UserRegistrationResponse* internal_default_instance() {
    return reinterpret_cast<const UserRegistrationResponse*>(
               &_UserRegistrationResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(UserRegistrationResponse& a, UserRegistrationResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(UserRegistrationResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UserRegistrationResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UserRegistrationResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UserRegistrationResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UserRegistrationResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UserRegistrationResponse& from) {
    UserRegistrationResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UserRegistrationResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "UserRegistrationResponse";
  }
  protected:
  explicit UserRegistrationResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResultFieldNumber = 1,
  };
  // .RegistrationResult result = 1;
  void clear_result();
  ::RegistrationResult result() const;
  void set_result(::RegistrationResult value);
  private:
  ::RegistrationResult _internal_result() const;
  void _internal_set_result(::RegistrationResult value);
  public:

  // @@protoc_insertion_point(class_scope:UserRegistrationResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int result_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2eproto;
};
// -------------------------------------------------------------------

class CarOperationRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CarOperationRequest) */ {
 public:
  inline CarOperationRequest() : CarOperationRequest(nullptr) {}
  ~CarOperationRequest() override;
  explicit PROTOBUF_CONSTEXPR CarOperationRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CarOperationRequest(const CarOperationRequest& from);
  CarOperationRequest(CarOperationRequest&& from) noexcept
    : CarOperationRequest() {
    *this = ::std::move(from);
  }

  inline CarOperationRequest& operator=(const CarOperationRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CarOperationRequest& operator=(CarOperationRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CarOperationRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const CarOperationRequest* internal_default_instance() {
    return reinterpret_cast<const CarOperationRequest*>(
               &_CarOperationRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(CarOperationRequest& a, CarOperationRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(CarOperationRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CarOperationRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CarOperationRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CarOperationRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CarOperationRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CarOperationRequest& from) {
    CarOperationRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CarOperationRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CarOperationRequest";
  }
  protected:
  explicit CarOperationRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLicenseFieldNumber = 3,
    kNewLicenseFieldNumber = 4,
    kOperationFieldNumber = 1,
    kUIdFieldNumber = 2,
  };
  // string license = 3;
  void clear_license();
  const std::string& license() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_license(ArgT0&& arg0, ArgT... args);
  std::string* mutable_license();
  PROTOBUF_NODISCARD std::string* release_license();
  void set_allocated_license(std::string* license);
  private:
  const std::string& _internal_license() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_license(const std::string& value);
  std::string* _internal_mutable_license();
  public:

  // optional string new_license = 4;
  bool has_new_license() const;
  private:
  bool _internal_has_new_license() const;
  public:
  void clear_new_license();
  const std::string& new_license() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_new_license(ArgT0&& arg0, ArgT... args);
  std::string* mutable_new_license();
  PROTOBUF_NODISCARD std::string* release_new_license();
  void set_allocated_new_license(std::string* new_license);
  private:
  const std::string& _internal_new_license() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_new_license(const std::string& value);
  std::string* _internal_mutable_new_license();
  public:

  // .CarOperation operation = 1;
  void clear_operation();
  ::CarOperation operation() const;
  void set_operation(::CarOperation value);
  private:
  ::CarOperation _internal_operation() const;
  void _internal_set_operation(::CarOperation value);
  public:

  // int32 u_id = 2;
  void clear_u_id();
  int32_t u_id() const;
  void set_u_id(int32_t value);
  private:
  int32_t _internal_u_id() const;
  void _internal_set_u_id(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:CarOperationRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr license_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr new_license_;
    int operation_;
    int32_t u_id_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2eproto;
};
// -------------------------------------------------------------------

class CarOperationResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CarOperationResponse) */ {
 public:
  inline CarOperationResponse() : CarOperationResponse(nullptr) {}
  ~CarOperationResponse() override;
  explicit PROTOBUF_CONSTEXPR CarOperationResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CarOperationResponse(const CarOperationResponse& from);
  CarOperationResponse(CarOperationResponse&& from) noexcept
    : CarOperationResponse() {
    *this = ::std::move(from);
  }

  inline CarOperationResponse& operator=(const CarOperationResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline CarOperationResponse& operator=(CarOperationResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CarOperationResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const CarOperationResponse* internal_default_instance() {
    return reinterpret_cast<const CarOperationResponse*>(
               &_CarOperationResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(CarOperationResponse& a, CarOperationResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(CarOperationResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CarOperationResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CarOperationResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CarOperationResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CarOperationResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CarOperationResponse& from) {
    CarOperationResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CarOperationResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CarOperationResponse";
  }
  protected:
  explicit CarOperationResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResultFieldNumber = 1,
  };
  // .CarOperationResult result = 1;
  void clear_result();
  ::CarOperationResult result() const;
  void set_result(::CarOperationResult value);
  private:
  ::CarOperationResult _internal_result() const;
  void _internal_set_result(::CarOperationResult value);
  public:

  // @@protoc_insertion_point(class_scope:CarOperationResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int result_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2eproto;
};
// -------------------------------------------------------------------

class GetUserDataRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:GetUserDataRequest) */ {
 public:
  inline GetUserDataRequest() : GetUserDataRequest(nullptr) {}
  ~GetUserDataRequest() override;
  explicit PROTOBUF_CONSTEXPR GetUserDataRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetUserDataRequest(const GetUserDataRequest& from);
  GetUserDataRequest(GetUserDataRequest&& from) noexcept
    : GetUserDataRequest() {
    *this = ::std::move(from);
  }

  inline GetUserDataRequest& operator=(const GetUserDataRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetUserDataRequest& operator=(GetUserDataRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetUserDataRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetUserDataRequest* internal_default_instance() {
    return reinterpret_cast<const GetUserDataRequest*>(
               &_GetUserDataRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(GetUserDataRequest& a, GetUserDataRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetUserDataRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetUserDataRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetUserDataRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetUserDataRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetUserDataRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetUserDataRequest& from) {
    GetUserDataRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetUserDataRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "GetUserDataRequest";
  }
  protected:
  explicit GetUserDataRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUIdFieldNumber = 1,
  };
  // int32 u_id = 1;
  void clear_u_id();
  int32_t u_id() const;
  void set_u_id(int32_t value);
  private:
  int32_t _internal_u_id() const;
  void _internal_set_u_id(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:GetUserDataRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t u_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2eproto;
};
// -------------------------------------------------------------------

class GetUserDataResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:GetUserDataResponse) */ {
 public:
  inline GetUserDataResponse() : GetUserDataResponse(nullptr) {}
  ~GetUserDataResponse() override;
  explicit PROTOBUF_CONSTEXPR GetUserDataResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetUserDataResponse(const GetUserDataResponse& from);
  GetUserDataResponse(GetUserDataResponse&& from) noexcept
    : GetUserDataResponse() {
    *this = ::std::move(from);
  }

  inline GetUserDataResponse& operator=(const GetUserDataResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetUserDataResponse& operator=(GetUserDataResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetUserDataResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetUserDataResponse* internal_default_instance() {
    return reinterpret_cast<const GetUserDataResponse*>(
               &_GetUserDataResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(GetUserDataResponse& a, GetUserDataResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetUserDataResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetUserDataResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetUserDataResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetUserDataResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetUserDataResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetUserDataResponse& from) {
    GetUserDataResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetUserDataResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "GetUserDataResponse";
  }
  protected:
  explicit GetUserDataResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCarInfoArrFieldNumber = 1,
  };
  // repeated .CarInfo car_info_arr = 1;
  int car_info_arr_size() const;
  private:
  int _internal_car_info_arr_size() const;
  public:
  void clear_car_info_arr();
  ::CarInfo* mutable_car_info_arr(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CarInfo >*
      mutable_car_info_arr();
  private:
  const ::CarInfo& _internal_car_info_arr(int index) const;
  ::CarInfo* _internal_add_car_info_arr();
  public:
  const ::CarInfo& car_info_arr(int index) const;
  ::CarInfo* add_car_info_arr();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CarInfo >&
      car_info_arr() const;

  // @@protoc_insertion_point(class_scope:GetUserDataResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CarInfo > car_info_arr_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2eproto;
};
// -------------------------------------------------------------------

class AdminLoginRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:AdminLoginRequest) */ {
 public:
  inline AdminLoginRequest() : AdminLoginRequest(nullptr) {}
  ~AdminLoginRequest() override;
  explicit PROTOBUF_CONSTEXPR AdminLoginRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AdminLoginRequest(const AdminLoginRequest& from);
  AdminLoginRequest(AdminLoginRequest&& from) noexcept
    : AdminLoginRequest() {
    *this = ::std::move(from);
  }

  inline AdminLoginRequest& operator=(const AdminLoginRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline AdminLoginRequest& operator=(AdminLoginRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AdminLoginRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const AdminLoginRequest* internal_default_instance() {
    return reinterpret_cast<const AdminLoginRequest*>(
               &_AdminLoginRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(AdminLoginRequest& a, AdminLoginRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(AdminLoginRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AdminLoginRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AdminLoginRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AdminLoginRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AdminLoginRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AdminLoginRequest& from) {
    AdminLoginRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AdminLoginRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "AdminLoginRequest";
  }
  protected:
  explicit AdminLoginRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPasswordFieldNumber = 2,
    kPIdFieldNumber = 1,
  };
  // string password = 2;
  void clear_password();
  const std::string& password() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_password(ArgT0&& arg0, ArgT... args);
  std::string* mutable_password();
  PROTOBUF_NODISCARD std::string* release_password();
  void set_allocated_password(std::string* password);
  private:
  const std::string& _internal_password() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_password(const std::string& value);
  std::string* _internal_mutable_password();
  public:

  // int32 p_id = 1;
  void clear_p_id();
  int32_t p_id() const;
  void set_p_id(int32_t value);
  private:
  int32_t _internal_p_id() const;
  void _internal_set_p_id(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:AdminLoginRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr password_;
    int32_t p_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2eproto;
};
// -------------------------------------------------------------------

class AdminLoginResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:AdminLoginResponse) */ {
 public:
  inline AdminLoginResponse() : AdminLoginResponse(nullptr) {}
  ~AdminLoginResponse() override;
  explicit PROTOBUF_CONSTEXPR AdminLoginResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AdminLoginResponse(const AdminLoginResponse& from);
  AdminLoginResponse(AdminLoginResponse&& from) noexcept
    : AdminLoginResponse() {
    *this = ::std::move(from);
  }

  inline AdminLoginResponse& operator=(const AdminLoginResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline AdminLoginResponse& operator=(AdminLoginResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AdminLoginResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const AdminLoginResponse* internal_default_instance() {
    return reinterpret_cast<const AdminLoginResponse*>(
               &_AdminLoginResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(AdminLoginResponse& a, AdminLoginResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(AdminLoginResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AdminLoginResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AdminLoginResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AdminLoginResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AdminLoginResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AdminLoginResponse& from) {
    AdminLoginResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AdminLoginResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "AdminLoginResponse";
  }
  protected:
  explicit AdminLoginResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResultFieldNumber = 1,
  };
  // .LoginResult result = 1;
  void clear_result();
  ::LoginResult result() const;
  void set_result(::LoginResult value);
  private:
  ::LoginResult _internal_result() const;
  void _internal_set_result(::LoginResult value);
  public:

  // @@protoc_insertion_point(class_scope:AdminLoginResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int result_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2eproto;
};
// -------------------------------------------------------------------

class AdminGetDataRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:AdminGetDataRequest) */ {
 public:
  inline AdminGetDataRequest() : AdminGetDataRequest(nullptr) {}
  ~AdminGetDataRequest() override;
  explicit PROTOBUF_CONSTEXPR AdminGetDataRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AdminGetDataRequest(const AdminGetDataRequest& from);
  AdminGetDataRequest(AdminGetDataRequest&& from) noexcept
    : AdminGetDataRequest() {
    *this = ::std::move(from);
  }

  inline AdminGetDataRequest& operator=(const AdminGetDataRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline AdminGetDataRequest& operator=(AdminGetDataRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AdminGetDataRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const AdminGetDataRequest* internal_default_instance() {
    return reinterpret_cast<const AdminGetDataRequest*>(
               &_AdminGetDataRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(AdminGetDataRequest& a, AdminGetDataRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(AdminGetDataRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AdminGetDataRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AdminGetDataRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AdminGetDataRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AdminGetDataRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AdminGetDataRequest& from) {
    AdminGetDataRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AdminGetDataRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "AdminGetDataRequest";
  }
  protected:
  explicit AdminGetDataRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPIdFieldNumber = 1,
  };
  // int32 p_id = 1;
  void clear_p_id();
  int32_t p_id() const;
  void set_p_id(int32_t value);
  private:
  int32_t _internal_p_id() const;
  void _internal_set_p_id(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:AdminGetDataRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t p_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2eproto;
};
// -------------------------------------------------------------------

class AdminGetDataResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:AdminGetDataResponse) */ {
 public:
  inline AdminGetDataResponse() : AdminGetDataResponse(nullptr) {}
  ~AdminGetDataResponse() override;
  explicit PROTOBUF_CONSTEXPR AdminGetDataResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AdminGetDataResponse(const AdminGetDataResponse& from);
  AdminGetDataResponse(AdminGetDataResponse&& from) noexcept
    : AdminGetDataResponse() {
    *this = ::std::move(from);
  }

  inline AdminGetDataResponse& operator=(const AdminGetDataResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline AdminGetDataResponse& operator=(AdminGetDataResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AdminGetDataResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const AdminGetDataResponse* internal_default_instance() {
    return reinterpret_cast<const AdminGetDataResponse*>(
               &_AdminGetDataResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(AdminGetDataResponse& a, AdminGetDataResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(AdminGetDataResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AdminGetDataResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AdminGetDataResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AdminGetDataResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AdminGetDataResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AdminGetDataResponse& from) {
    AdminGetDataResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AdminGetDataResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "AdminGetDataResponse";
  }
  protected:
  explicit AdminGetDataResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSInfoArrFieldNumber = 2,
    kPInfoFieldNumber = 1,
  };
  // repeated .ParkingSpaceInfo s_info_arr = 2;
  int s_info_arr_size() const;
  private:
  int _internal_s_info_arr_size() const;
  public:
  void clear_s_info_arr();
  ::ParkingSpaceInfo* mutable_s_info_arr(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ParkingSpaceInfo >*
      mutable_s_info_arr();
  private:
  const ::ParkingSpaceInfo& _internal_s_info_arr(int index) const;
  ::ParkingSpaceInfo* _internal_add_s_info_arr();
  public:
  const ::ParkingSpaceInfo& s_info_arr(int index) const;
  ::ParkingSpaceInfo* add_s_info_arr();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ParkingSpaceInfo >&
      s_info_arr() const;

  // .ParkingInfo p_info = 1;
  bool has_p_info() const;
  private:
  bool _internal_has_p_info() const;
  public:
  void clear_p_info();
  const ::ParkingInfo& p_info() const;
  PROTOBUF_NODISCARD ::ParkingInfo* release_p_info();
  ::ParkingInfo* mutable_p_info();
  void set_allocated_p_info(::ParkingInfo* p_info);
  private:
  const ::ParkingInfo& _internal_p_info() const;
  ::ParkingInfo* _internal_mutable_p_info();
  public:
  void unsafe_arena_set_allocated_p_info(
      ::ParkingInfo* p_info);
  ::ParkingInfo* unsafe_arena_release_p_info();

  // @@protoc_insertion_point(class_scope:AdminGetDataResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ParkingSpaceInfo > s_info_arr_;
    ::ParkingInfo* p_info_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// ParkingInfo

// int32 p_id = 1;
inline void ParkingInfo::clear_p_id() {
  _impl_.p_id_ = 0;
}
inline int32_t ParkingInfo::_internal_p_id() const {
  return _impl_.p_id_;
}
inline int32_t ParkingInfo::p_id() const {
  // @@protoc_insertion_point(field_get:ParkingInfo.p_id)
  return _internal_p_id();
}
inline void ParkingInfo::_internal_set_p_id(int32_t value) {
  
  _impl_.p_id_ = value;
}
inline void ParkingInfo::set_p_id(int32_t value) {
  _internal_set_p_id(value);
  // @@protoc_insertion_point(field_set:ParkingInfo.p_id)
}

// int32 temperature = 2;
inline void ParkingInfo::clear_temperature() {
  _impl_.temperature_ = 0;
}
inline int32_t ParkingInfo::_internal_temperature() const {
  return _impl_.temperature_;
}
inline int32_t ParkingInfo::temperature() const {
  // @@protoc_insertion_point(field_get:ParkingInfo.temperature)
  return _internal_temperature();
}
inline void ParkingInfo::_internal_set_temperature(int32_t value) {
  
  _impl_.temperature_ = value;
}
inline void ParkingInfo::set_temperature(int32_t value) {
  _internal_set_temperature(value);
  // @@protoc_insertion_point(field_set:ParkingInfo.temperature)
}

// int32 humidity = 3;
inline void ParkingInfo::clear_humidity() {
  _impl_.humidity_ = 0;
}
inline int32_t ParkingInfo::_internal_humidity() const {
  return _impl_.humidity_;
}
inline int32_t ParkingInfo::humidity() const {
  // @@protoc_insertion_point(field_get:ParkingInfo.humidity)
  return _internal_humidity();
}
inline void ParkingInfo::_internal_set_humidity(int32_t value) {
  
  _impl_.humidity_ = value;
}
inline void ParkingInfo::set_humidity(int32_t value) {
  _internal_set_humidity(value);
  // @@protoc_insertion_point(field_set:ParkingInfo.humidity)
}

// int32 weather = 4;
inline void ParkingInfo::clear_weather() {
  _impl_.weather_ = 0;
}
inline int32_t ParkingInfo::_internal_weather() const {
  return _impl_.weather_;
}
inline int32_t ParkingInfo::weather() const {
  // @@protoc_insertion_point(field_get:ParkingInfo.weather)
  return _internal_weather();
}
inline void ParkingInfo::_internal_set_weather(int32_t value) {
  
  _impl_.weather_ = value;
}
inline void ParkingInfo::set_weather(int32_t value) {
  _internal_set_weather(value);
  // @@protoc_insertion_point(field_set:ParkingInfo.weather)
}

// -------------------------------------------------------------------

// ParkingSpaceInfo

// int32 s_id = 1;
inline void ParkingSpaceInfo::clear_s_id() {
  _impl_.s_id_ = 0;
}
inline int32_t ParkingSpaceInfo::_internal_s_id() const {
  return _impl_.s_id_;
}
inline int32_t ParkingSpaceInfo::s_id() const {
  // @@protoc_insertion_point(field_get:ParkingSpaceInfo.s_id)
  return _internal_s_id();
}
inline void ParkingSpaceInfo::_internal_set_s_id(int32_t value) {
  
  _impl_.s_id_ = value;
}
inline void ParkingSpaceInfo::set_s_id(int32_t value) {
  _internal_set_s_id(value);
  // @@protoc_insertion_point(field_set:ParkingSpaceInfo.s_id)
}

// int32 temperature = 2;
inline void ParkingSpaceInfo::clear_temperature() {
  _impl_.temperature_ = 0;
}
inline int32_t ParkingSpaceInfo::_internal_temperature() const {
  return _impl_.temperature_;
}
inline int32_t ParkingSpaceInfo::temperature() const {
  // @@protoc_insertion_point(field_get:ParkingSpaceInfo.temperature)
  return _internal_temperature();
}
inline void ParkingSpaceInfo::_internal_set_temperature(int32_t value) {
  
  _impl_.temperature_ = value;
}
inline void ParkingSpaceInfo::set_temperature(int32_t value) {
  _internal_set_temperature(value);
  // @@protoc_insertion_point(field_set:ParkingSpaceInfo.temperature)
}

// int32 humidity = 3;
inline void ParkingSpaceInfo::clear_humidity() {
  _impl_.humidity_ = 0;
}
inline int32_t ParkingSpaceInfo::_internal_humidity() const {
  return _impl_.humidity_;
}
inline int32_t ParkingSpaceInfo::humidity() const {
  // @@protoc_insertion_point(field_get:ParkingSpaceInfo.humidity)
  return _internal_humidity();
}
inline void ParkingSpaceInfo::_internal_set_humidity(int32_t value) {
  
  _impl_.humidity_ = value;
}
inline void ParkingSpaceInfo::set_humidity(int32_t value) {
  _internal_set_humidity(value);
  // @@protoc_insertion_point(field_set:ParkingSpaceInfo.humidity)
}

// .Alarm alarm = 4;
inline void ParkingSpaceInfo::clear_alarm() {
  _impl_.alarm_ = 0;
}
inline ::Alarm ParkingSpaceInfo::_internal_alarm() const {
  return static_cast< ::Alarm >(_impl_.alarm_);
}
inline ::Alarm ParkingSpaceInfo::alarm() const {
  // @@protoc_insertion_point(field_get:ParkingSpaceInfo.alarm)
  return _internal_alarm();
}
inline void ParkingSpaceInfo::_internal_set_alarm(::Alarm value) {
  
  _impl_.alarm_ = value;
}
inline void ParkingSpaceInfo::set_alarm(::Alarm value) {
  _internal_set_alarm(value);
  // @@protoc_insertion_point(field_set:ParkingSpaceInfo.alarm)
}

// -------------------------------------------------------------------

// CarInfo

// int32 p_temperature = 1;
inline void CarInfo::clear_p_temperature() {
  _impl_.p_temperature_ = 0;
}
inline int32_t CarInfo::_internal_p_temperature() const {
  return _impl_.p_temperature_;
}
inline int32_t CarInfo::p_temperature() const {
  // @@protoc_insertion_point(field_get:CarInfo.p_temperature)
  return _internal_p_temperature();
}
inline void CarInfo::_internal_set_p_temperature(int32_t value) {
  
  _impl_.p_temperature_ = value;
}
inline void CarInfo::set_p_temperature(int32_t value) {
  _internal_set_p_temperature(value);
  // @@protoc_insertion_point(field_set:CarInfo.p_temperature)
}

// int32 p_humidity = 2;
inline void CarInfo::clear_p_humidity() {
  _impl_.p_humidity_ = 0;
}
inline int32_t CarInfo::_internal_p_humidity() const {
  return _impl_.p_humidity_;
}
inline int32_t CarInfo::p_humidity() const {
  // @@protoc_insertion_point(field_get:CarInfo.p_humidity)
  return _internal_p_humidity();
}
inline void CarInfo::_internal_set_p_humidity(int32_t value) {
  
  _impl_.p_humidity_ = value;
}
inline void CarInfo::set_p_humidity(int32_t value) {
  _internal_set_p_humidity(value);
  // @@protoc_insertion_point(field_set:CarInfo.p_humidity)
}

// int32 p_weather = 3;
inline void CarInfo::clear_p_weather() {
  _impl_.p_weather_ = 0;
}
inline int32_t CarInfo::_internal_p_weather() const {
  return _impl_.p_weather_;
}
inline int32_t CarInfo::p_weather() const {
  // @@protoc_insertion_point(field_get:CarInfo.p_weather)
  return _internal_p_weather();
}
inline void CarInfo::_internal_set_p_weather(int32_t value) {
  
  _impl_.p_weather_ = value;
}
inline void CarInfo::set_p_weather(int32_t value) {
  _internal_set_p_weather(value);
  // @@protoc_insertion_point(field_set:CarInfo.p_weather)
}

// string p_address = 4;
inline void CarInfo::clear_p_address() {
  _impl_.p_address_.ClearToEmpty();
}
inline const std::string& CarInfo::p_address() const {
  // @@protoc_insertion_point(field_get:CarInfo.p_address)
  return _internal_p_address();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CarInfo::set_p_address(ArgT0&& arg0, ArgT... args) {
 
 _impl_.p_address_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CarInfo.p_address)
}
inline std::string* CarInfo::mutable_p_address() {
  std::string* _s = _internal_mutable_p_address();
  // @@protoc_insertion_point(field_mutable:CarInfo.p_address)
  return _s;
}
inline const std::string& CarInfo::_internal_p_address() const {
  return _impl_.p_address_.Get();
}
inline void CarInfo::_internal_set_p_address(const std::string& value) {
  
  _impl_.p_address_.Set(value, GetArenaForAllocation());
}
inline std::string* CarInfo::_internal_mutable_p_address() {
  
  return _impl_.p_address_.Mutable(GetArenaForAllocation());
}
inline std::string* CarInfo::release_p_address() {
  // @@protoc_insertion_point(field_release:CarInfo.p_address)
  return _impl_.p_address_.Release();
}
inline void CarInfo::set_allocated_p_address(std::string* p_address) {
  if (p_address != nullptr) {
    
  } else {
    
  }
  _impl_.p_address_.SetAllocated(p_address, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.p_address_.IsDefault()) {
    _impl_.p_address_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CarInfo.p_address)
}

// int32 s_id = 5;
inline void CarInfo::clear_s_id() {
  _impl_.s_id_ = 0;
}
inline int32_t CarInfo::_internal_s_id() const {
  return _impl_.s_id_;
}
inline int32_t CarInfo::s_id() const {
  // @@protoc_insertion_point(field_get:CarInfo.s_id)
  return _internal_s_id();
}
inline void CarInfo::_internal_set_s_id(int32_t value) {
  
  _impl_.s_id_ = value;
}
inline void CarInfo::set_s_id(int32_t value) {
  _internal_set_s_id(value);
  // @@protoc_insertion_point(field_set:CarInfo.s_id)
}

// int32 s_temperature = 6;
inline void CarInfo::clear_s_temperature() {
  _impl_.s_temperature_ = 0;
}
inline int32_t CarInfo::_internal_s_temperature() const {
  return _impl_.s_temperature_;
}
inline int32_t CarInfo::s_temperature() const {
  // @@protoc_insertion_point(field_get:CarInfo.s_temperature)
  return _internal_s_temperature();
}
inline void CarInfo::_internal_set_s_temperature(int32_t value) {
  
  _impl_.s_temperature_ = value;
}
inline void CarInfo::set_s_temperature(int32_t value) {
  _internal_set_s_temperature(value);
  // @@protoc_insertion_point(field_set:CarInfo.s_temperature)
}

// int32 s_humidity = 7;
inline void CarInfo::clear_s_humidity() {
  _impl_.s_humidity_ = 0;
}
inline int32_t CarInfo::_internal_s_humidity() const {
  return _impl_.s_humidity_;
}
inline int32_t CarInfo::s_humidity() const {
  // @@protoc_insertion_point(field_get:CarInfo.s_humidity)
  return _internal_s_humidity();
}
inline void CarInfo::_internal_set_s_humidity(int32_t value) {
  
  _impl_.s_humidity_ = value;
}
inline void CarInfo::set_s_humidity(int32_t value) {
  _internal_set_s_humidity(value);
  // @@protoc_insertion_point(field_set:CarInfo.s_humidity)
}

// .Alarm s_alarm = 8;
inline void CarInfo::clear_s_alarm() {
  _impl_.s_alarm_ = 0;
}
inline ::Alarm CarInfo::_internal_s_alarm() const {
  return static_cast< ::Alarm >(_impl_.s_alarm_);
}
inline ::Alarm CarInfo::s_alarm() const {
  // @@protoc_insertion_point(field_get:CarInfo.s_alarm)
  return _internal_s_alarm();
}
inline void CarInfo::_internal_set_s_alarm(::Alarm value) {
  
  _impl_.s_alarm_ = value;
}
inline void CarInfo::set_s_alarm(::Alarm value) {
  _internal_set_s_alarm(value);
  // @@protoc_insertion_point(field_set:CarInfo.s_alarm)
}

// -------------------------------------------------------------------

// LPCheckRequest

// int32 model = 1;
inline void LPCheckRequest::clear_model() {
  _impl_.model_ = 0;
}
inline int32_t LPCheckRequest::_internal_model() const {
  return _impl_.model_;
}
inline int32_t LPCheckRequest::model() const {
  // @@protoc_insertion_point(field_get:LPCheckRequest.model)
  return _internal_model();
}
inline void LPCheckRequest::_internal_set_model(int32_t value) {
  
  _impl_.model_ = value;
}
inline void LPCheckRequest::set_model(int32_t value) {
  _internal_set_model(value);
  // @@protoc_insertion_point(field_set:LPCheckRequest.model)
}

// int32 parking_id = 2;
inline void LPCheckRequest::clear_parking_id() {
  _impl_.parking_id_ = 0;
}
inline int32_t LPCheckRequest::_internal_parking_id() const {
  return _impl_.parking_id_;
}
inline int32_t LPCheckRequest::parking_id() const {
  // @@protoc_insertion_point(field_get:LPCheckRequest.parking_id)
  return _internal_parking_id();
}
inline void LPCheckRequest::_internal_set_parking_id(int32_t value) {
  
  _impl_.parking_id_ = value;
}
inline void LPCheckRequest::set_parking_id(int32_t value) {
  _internal_set_parking_id(value);
  // @@protoc_insertion_point(field_set:LPCheckRequest.parking_id)
}

// int32 parking_space_id = 3;
inline void LPCheckRequest::clear_parking_space_id() {
  _impl_.parking_space_id_ = 0;
}
inline int32_t LPCheckRequest::_internal_parking_space_id() const {
  return _impl_.parking_space_id_;
}
inline int32_t LPCheckRequest::parking_space_id() const {
  // @@protoc_insertion_point(field_get:LPCheckRequest.parking_space_id)
  return _internal_parking_space_id();
}
inline void LPCheckRequest::_internal_set_parking_space_id(int32_t value) {
  
  _impl_.parking_space_id_ = value;
}
inline void LPCheckRequest::set_parking_space_id(int32_t value) {
  _internal_set_parking_space_id(value);
  // @@protoc_insertion_point(field_set:LPCheckRequest.parking_space_id)
}

// string license = 4;
inline void LPCheckRequest::clear_license() {
  _impl_.license_.ClearToEmpty();
}
inline const std::string& LPCheckRequest::license() const {
  // @@protoc_insertion_point(field_get:LPCheckRequest.license)
  return _internal_license();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LPCheckRequest::set_license(ArgT0&& arg0, ArgT... args) {
 
 _impl_.license_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:LPCheckRequest.license)
}
inline std::string* LPCheckRequest::mutable_license() {
  std::string* _s = _internal_mutable_license();
  // @@protoc_insertion_point(field_mutable:LPCheckRequest.license)
  return _s;
}
inline const std::string& LPCheckRequest::_internal_license() const {
  return _impl_.license_.Get();
}
inline void LPCheckRequest::_internal_set_license(const std::string& value) {
  
  _impl_.license_.Set(value, GetArenaForAllocation());
}
inline std::string* LPCheckRequest::_internal_mutable_license() {
  
  return _impl_.license_.Mutable(GetArenaForAllocation());
}
inline std::string* LPCheckRequest::release_license() {
  // @@protoc_insertion_point(field_release:LPCheckRequest.license)
  return _impl_.license_.Release();
}
inline void LPCheckRequest::set_allocated_license(std::string* license) {
  if (license != nullptr) {
    
  } else {
    
  }
  _impl_.license_.SetAllocated(license, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.license_.IsDefault()) {
    _impl_.license_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:LPCheckRequest.license)
}

// -------------------------------------------------------------------

// LPCheckResponse

// bool result = 1;
inline void LPCheckResponse::clear_result() {
  _impl_.result_ = false;
}
inline bool LPCheckResponse::_internal_result() const {
  return _impl_.result_;
}
inline bool LPCheckResponse::result() const {
  // @@protoc_insertion_point(field_get:LPCheckResponse.result)
  return _internal_result();
}
inline void LPCheckResponse::_internal_set_result(bool value) {
  
  _impl_.result_ = value;
}
inline void LPCheckResponse::set_result(bool value) {
  _internal_set_result(value);
  // @@protoc_insertion_point(field_set:LPCheckResponse.result)
}

// int32 balance = 2;
inline void LPCheckResponse::clear_balance() {
  _impl_.balance_ = 0;
}
inline int32_t LPCheckResponse::_internal_balance() const {
  return _impl_.balance_;
}
inline int32_t LPCheckResponse::balance() const {
  // @@protoc_insertion_point(field_get:LPCheckResponse.balance)
  return _internal_balance();
}
inline void LPCheckResponse::_internal_set_balance(int32_t value) {
  
  _impl_.balance_ = value;
}
inline void LPCheckResponse::set_balance(int32_t value) {
  _internal_set_balance(value);
  // @@protoc_insertion_point(field_set:LPCheckResponse.balance)
}

// -------------------------------------------------------------------

// UploadInfoRequest

// .ParkingInfo p_info = 1;
inline bool UploadInfoRequest::_internal_has_p_info() const {
  return this != internal_default_instance() && _impl_.p_info_ != nullptr;
}
inline bool UploadInfoRequest::has_p_info() const {
  return _internal_has_p_info();
}
inline void UploadInfoRequest::clear_p_info() {
  if (GetArenaForAllocation() == nullptr && _impl_.p_info_ != nullptr) {
    delete _impl_.p_info_;
  }
  _impl_.p_info_ = nullptr;
}
inline const ::ParkingInfo& UploadInfoRequest::_internal_p_info() const {
  const ::ParkingInfo* p = _impl_.p_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::ParkingInfo&>(
      ::_ParkingInfo_default_instance_);
}
inline const ::ParkingInfo& UploadInfoRequest::p_info() const {
  // @@protoc_insertion_point(field_get:UploadInfoRequest.p_info)
  return _internal_p_info();
}
inline void UploadInfoRequest::unsafe_arena_set_allocated_p_info(
    ::ParkingInfo* p_info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.p_info_);
  }
  _impl_.p_info_ = p_info;
  if (p_info) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:UploadInfoRequest.p_info)
}
inline ::ParkingInfo* UploadInfoRequest::release_p_info() {
  
  ::ParkingInfo* temp = _impl_.p_info_;
  _impl_.p_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ParkingInfo* UploadInfoRequest::unsafe_arena_release_p_info() {
  // @@protoc_insertion_point(field_release:UploadInfoRequest.p_info)
  
  ::ParkingInfo* temp = _impl_.p_info_;
  _impl_.p_info_ = nullptr;
  return temp;
}
inline ::ParkingInfo* UploadInfoRequest::_internal_mutable_p_info() {
  
  if (_impl_.p_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::ParkingInfo>(GetArenaForAllocation());
    _impl_.p_info_ = p;
  }
  return _impl_.p_info_;
}
inline ::ParkingInfo* UploadInfoRequest::mutable_p_info() {
  ::ParkingInfo* _msg = _internal_mutable_p_info();
  // @@protoc_insertion_point(field_mutable:UploadInfoRequest.p_info)
  return _msg;
}
inline void UploadInfoRequest::set_allocated_p_info(::ParkingInfo* p_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.p_info_;
  }
  if (p_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(p_info);
    if (message_arena != submessage_arena) {
      p_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, p_info, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.p_info_ = p_info;
  // @@protoc_insertion_point(field_set_allocated:UploadInfoRequest.p_info)
}

// repeated .ParkingSpaceInfo s_info_arr = 2;
inline int UploadInfoRequest::_internal_s_info_arr_size() const {
  return _impl_.s_info_arr_.size();
}
inline int UploadInfoRequest::s_info_arr_size() const {
  return _internal_s_info_arr_size();
}
inline void UploadInfoRequest::clear_s_info_arr() {
  _impl_.s_info_arr_.Clear();
}
inline ::ParkingSpaceInfo* UploadInfoRequest::mutable_s_info_arr(int index) {
  // @@protoc_insertion_point(field_mutable:UploadInfoRequest.s_info_arr)
  return _impl_.s_info_arr_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ParkingSpaceInfo >*
UploadInfoRequest::mutable_s_info_arr() {
  // @@protoc_insertion_point(field_mutable_list:UploadInfoRequest.s_info_arr)
  return &_impl_.s_info_arr_;
}
inline const ::ParkingSpaceInfo& UploadInfoRequest::_internal_s_info_arr(int index) const {
  return _impl_.s_info_arr_.Get(index);
}
inline const ::ParkingSpaceInfo& UploadInfoRequest::s_info_arr(int index) const {
  // @@protoc_insertion_point(field_get:UploadInfoRequest.s_info_arr)
  return _internal_s_info_arr(index);
}
inline ::ParkingSpaceInfo* UploadInfoRequest::_internal_add_s_info_arr() {
  return _impl_.s_info_arr_.Add();
}
inline ::ParkingSpaceInfo* UploadInfoRequest::add_s_info_arr() {
  ::ParkingSpaceInfo* _add = _internal_add_s_info_arr();
  // @@protoc_insertion_point(field_add:UploadInfoRequest.s_info_arr)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ParkingSpaceInfo >&
UploadInfoRequest::s_info_arr() const {
  // @@protoc_insertion_point(field_list:UploadInfoRequest.s_info_arr)
  return _impl_.s_info_arr_;
}

// -------------------------------------------------------------------

// UploadInfoResponse

// int32 result = 1;
inline void UploadInfoResponse::clear_result() {
  _impl_.result_ = 0;
}
inline int32_t UploadInfoResponse::_internal_result() const {
  return _impl_.result_;
}
inline int32_t UploadInfoResponse::result() const {
  // @@protoc_insertion_point(field_get:UploadInfoResponse.result)
  return _internal_result();
}
inline void UploadInfoResponse::_internal_set_result(int32_t value) {
  
  _impl_.result_ = value;
}
inline void UploadInfoResponse::set_result(int32_t value) {
  _internal_set_result(value);
  // @@protoc_insertion_point(field_set:UploadInfoResponse.result)
}

// -------------------------------------------------------------------

// UserLoginRequest

// string username = 1;
inline void UserLoginRequest::clear_username() {
  _impl_.username_.ClearToEmpty();
}
inline const std::string& UserLoginRequest::username() const {
  // @@protoc_insertion_point(field_get:UserLoginRequest.username)
  return _internal_username();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UserLoginRequest::set_username(ArgT0&& arg0, ArgT... args) {
 
 _impl_.username_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:UserLoginRequest.username)
}
inline std::string* UserLoginRequest::mutable_username() {
  std::string* _s = _internal_mutable_username();
  // @@protoc_insertion_point(field_mutable:UserLoginRequest.username)
  return _s;
}
inline const std::string& UserLoginRequest::_internal_username() const {
  return _impl_.username_.Get();
}
inline void UserLoginRequest::_internal_set_username(const std::string& value) {
  
  _impl_.username_.Set(value, GetArenaForAllocation());
}
inline std::string* UserLoginRequest::_internal_mutable_username() {
  
  return _impl_.username_.Mutable(GetArenaForAllocation());
}
inline std::string* UserLoginRequest::release_username() {
  // @@protoc_insertion_point(field_release:UserLoginRequest.username)
  return _impl_.username_.Release();
}
inline void UserLoginRequest::set_allocated_username(std::string* username) {
  if (username != nullptr) {
    
  } else {
    
  }
  _impl_.username_.SetAllocated(username, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.username_.IsDefault()) {
    _impl_.username_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:UserLoginRequest.username)
}

// string password = 2;
inline void UserLoginRequest::clear_password() {
  _impl_.password_.ClearToEmpty();
}
inline const std::string& UserLoginRequest::password() const {
  // @@protoc_insertion_point(field_get:UserLoginRequest.password)
  return _internal_password();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UserLoginRequest::set_password(ArgT0&& arg0, ArgT... args) {
 
 _impl_.password_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:UserLoginRequest.password)
}
inline std::string* UserLoginRequest::mutable_password() {
  std::string* _s = _internal_mutable_password();
  // @@protoc_insertion_point(field_mutable:UserLoginRequest.password)
  return _s;
}
inline const std::string& UserLoginRequest::_internal_password() const {
  return _impl_.password_.Get();
}
inline void UserLoginRequest::_internal_set_password(const std::string& value) {
  
  _impl_.password_.Set(value, GetArenaForAllocation());
}
inline std::string* UserLoginRequest::_internal_mutable_password() {
  
  return _impl_.password_.Mutable(GetArenaForAllocation());
}
inline std::string* UserLoginRequest::release_password() {
  // @@protoc_insertion_point(field_release:UserLoginRequest.password)
  return _impl_.password_.Release();
}
inline void UserLoginRequest::set_allocated_password(std::string* password) {
  if (password != nullptr) {
    
  } else {
    
  }
  _impl_.password_.SetAllocated(password, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.password_.IsDefault()) {
    _impl_.password_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:UserLoginRequest.password)
}

// -------------------------------------------------------------------

// UserLoginResponse

// .LoginResult result = 1;
inline void UserLoginResponse::clear_result() {
  _impl_.result_ = 0;
}
inline ::LoginResult UserLoginResponse::_internal_result() const {
  return static_cast< ::LoginResult >(_impl_.result_);
}
inline ::LoginResult UserLoginResponse::result() const {
  // @@protoc_insertion_point(field_get:UserLoginResponse.result)
  return _internal_result();
}
inline void UserLoginResponse::_internal_set_result(::LoginResult value) {
  
  _impl_.result_ = value;
}
inline void UserLoginResponse::set_result(::LoginResult value) {
  _internal_set_result(value);
  // @@protoc_insertion_point(field_set:UserLoginResponse.result)
}

// int32 u_id = 2;
inline void UserLoginResponse::clear_u_id() {
  _impl_.u_id_ = 0;
}
inline int32_t UserLoginResponse::_internal_u_id() const {
  return _impl_.u_id_;
}
inline int32_t UserLoginResponse::u_id() const {
  // @@protoc_insertion_point(field_get:UserLoginResponse.u_id)
  return _internal_u_id();
}
inline void UserLoginResponse::_internal_set_u_id(int32_t value) {
  
  _impl_.u_id_ = value;
}
inline void UserLoginResponse::set_u_id(int32_t value) {
  _internal_set_u_id(value);
  // @@protoc_insertion_point(field_set:UserLoginResponse.u_id)
}

// -------------------------------------------------------------------

// UserRegistrationRequest

// string username = 1;
inline void UserRegistrationRequest::clear_username() {
  _impl_.username_.ClearToEmpty();
}
inline const std::string& UserRegistrationRequest::username() const {
  // @@protoc_insertion_point(field_get:UserRegistrationRequest.username)
  return _internal_username();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UserRegistrationRequest::set_username(ArgT0&& arg0, ArgT... args) {
 
 _impl_.username_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:UserRegistrationRequest.username)
}
inline std::string* UserRegistrationRequest::mutable_username() {
  std::string* _s = _internal_mutable_username();
  // @@protoc_insertion_point(field_mutable:UserRegistrationRequest.username)
  return _s;
}
inline const std::string& UserRegistrationRequest::_internal_username() const {
  return _impl_.username_.Get();
}
inline void UserRegistrationRequest::_internal_set_username(const std::string& value) {
  
  _impl_.username_.Set(value, GetArenaForAllocation());
}
inline std::string* UserRegistrationRequest::_internal_mutable_username() {
  
  return _impl_.username_.Mutable(GetArenaForAllocation());
}
inline std::string* UserRegistrationRequest::release_username() {
  // @@protoc_insertion_point(field_release:UserRegistrationRequest.username)
  return _impl_.username_.Release();
}
inline void UserRegistrationRequest::set_allocated_username(std::string* username) {
  if (username != nullptr) {
    
  } else {
    
  }
  _impl_.username_.SetAllocated(username, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.username_.IsDefault()) {
    _impl_.username_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:UserRegistrationRequest.username)
}

// string password = 2;
inline void UserRegistrationRequest::clear_password() {
  _impl_.password_.ClearToEmpty();
}
inline const std::string& UserRegistrationRequest::password() const {
  // @@protoc_insertion_point(field_get:UserRegistrationRequest.password)
  return _internal_password();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UserRegistrationRequest::set_password(ArgT0&& arg0, ArgT... args) {
 
 _impl_.password_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:UserRegistrationRequest.password)
}
inline std::string* UserRegistrationRequest::mutable_password() {
  std::string* _s = _internal_mutable_password();
  // @@protoc_insertion_point(field_mutable:UserRegistrationRequest.password)
  return _s;
}
inline const std::string& UserRegistrationRequest::_internal_password() const {
  return _impl_.password_.Get();
}
inline void UserRegistrationRequest::_internal_set_password(const std::string& value) {
  
  _impl_.password_.Set(value, GetArenaForAllocation());
}
inline std::string* UserRegistrationRequest::_internal_mutable_password() {
  
  return _impl_.password_.Mutable(GetArenaForAllocation());
}
inline std::string* UserRegistrationRequest::release_password() {
  // @@protoc_insertion_point(field_release:UserRegistrationRequest.password)
  return _impl_.password_.Release();
}
inline void UserRegistrationRequest::set_allocated_password(std::string* password) {
  if (password != nullptr) {
    
  } else {
    
  }
  _impl_.password_.SetAllocated(password, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.password_.IsDefault()) {
    _impl_.password_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:UserRegistrationRequest.password)
}

// -------------------------------------------------------------------

// UserRegistrationResponse

// .RegistrationResult result = 1;
inline void UserRegistrationResponse::clear_result() {
  _impl_.result_ = 0;
}
inline ::RegistrationResult UserRegistrationResponse::_internal_result() const {
  return static_cast< ::RegistrationResult >(_impl_.result_);
}
inline ::RegistrationResult UserRegistrationResponse::result() const {
  // @@protoc_insertion_point(field_get:UserRegistrationResponse.result)
  return _internal_result();
}
inline void UserRegistrationResponse::_internal_set_result(::RegistrationResult value) {
  
  _impl_.result_ = value;
}
inline void UserRegistrationResponse::set_result(::RegistrationResult value) {
  _internal_set_result(value);
  // @@protoc_insertion_point(field_set:UserRegistrationResponse.result)
}

// -------------------------------------------------------------------

// CarOperationRequest

// .CarOperation operation = 1;
inline void CarOperationRequest::clear_operation() {
  _impl_.operation_ = 0;
}
inline ::CarOperation CarOperationRequest::_internal_operation() const {
  return static_cast< ::CarOperation >(_impl_.operation_);
}
inline ::CarOperation CarOperationRequest::operation() const {
  // @@protoc_insertion_point(field_get:CarOperationRequest.operation)
  return _internal_operation();
}
inline void CarOperationRequest::_internal_set_operation(::CarOperation value) {
  
  _impl_.operation_ = value;
}
inline void CarOperationRequest::set_operation(::CarOperation value) {
  _internal_set_operation(value);
  // @@protoc_insertion_point(field_set:CarOperationRequest.operation)
}

// int32 u_id = 2;
inline void CarOperationRequest::clear_u_id() {
  _impl_.u_id_ = 0;
}
inline int32_t CarOperationRequest::_internal_u_id() const {
  return _impl_.u_id_;
}
inline int32_t CarOperationRequest::u_id() const {
  // @@protoc_insertion_point(field_get:CarOperationRequest.u_id)
  return _internal_u_id();
}
inline void CarOperationRequest::_internal_set_u_id(int32_t value) {
  
  _impl_.u_id_ = value;
}
inline void CarOperationRequest::set_u_id(int32_t value) {
  _internal_set_u_id(value);
  // @@protoc_insertion_point(field_set:CarOperationRequest.u_id)
}

// string license = 3;
inline void CarOperationRequest::clear_license() {
  _impl_.license_.ClearToEmpty();
}
inline const std::string& CarOperationRequest::license() const {
  // @@protoc_insertion_point(field_get:CarOperationRequest.license)
  return _internal_license();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CarOperationRequest::set_license(ArgT0&& arg0, ArgT... args) {
 
 _impl_.license_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CarOperationRequest.license)
}
inline std::string* CarOperationRequest::mutable_license() {
  std::string* _s = _internal_mutable_license();
  // @@protoc_insertion_point(field_mutable:CarOperationRequest.license)
  return _s;
}
inline const std::string& CarOperationRequest::_internal_license() const {
  return _impl_.license_.Get();
}
inline void CarOperationRequest::_internal_set_license(const std::string& value) {
  
  _impl_.license_.Set(value, GetArenaForAllocation());
}
inline std::string* CarOperationRequest::_internal_mutable_license() {
  
  return _impl_.license_.Mutable(GetArenaForAllocation());
}
inline std::string* CarOperationRequest::release_license() {
  // @@protoc_insertion_point(field_release:CarOperationRequest.license)
  return _impl_.license_.Release();
}
inline void CarOperationRequest::set_allocated_license(std::string* license) {
  if (license != nullptr) {
    
  } else {
    
  }
  _impl_.license_.SetAllocated(license, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.license_.IsDefault()) {
    _impl_.license_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CarOperationRequest.license)
}

// optional string new_license = 4;
inline bool CarOperationRequest::_internal_has_new_license() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CarOperationRequest::has_new_license() const {
  return _internal_has_new_license();
}
inline void CarOperationRequest::clear_new_license() {
  _impl_.new_license_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CarOperationRequest::new_license() const {
  // @@protoc_insertion_point(field_get:CarOperationRequest.new_license)
  return _internal_new_license();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CarOperationRequest::set_new_license(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.new_license_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CarOperationRequest.new_license)
}
inline std::string* CarOperationRequest::mutable_new_license() {
  std::string* _s = _internal_mutable_new_license();
  // @@protoc_insertion_point(field_mutable:CarOperationRequest.new_license)
  return _s;
}
inline const std::string& CarOperationRequest::_internal_new_license() const {
  return _impl_.new_license_.Get();
}
inline void CarOperationRequest::_internal_set_new_license(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.new_license_.Set(value, GetArenaForAllocation());
}
inline std::string* CarOperationRequest::_internal_mutable_new_license() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.new_license_.Mutable(GetArenaForAllocation());
}
inline std::string* CarOperationRequest::release_new_license() {
  // @@protoc_insertion_point(field_release:CarOperationRequest.new_license)
  if (!_internal_has_new_license()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.new_license_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.new_license_.IsDefault()) {
    _impl_.new_license_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CarOperationRequest::set_allocated_new_license(std::string* new_license) {
  if (new_license != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.new_license_.SetAllocated(new_license, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.new_license_.IsDefault()) {
    _impl_.new_license_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CarOperationRequest.new_license)
}

// -------------------------------------------------------------------

// CarOperationResponse

// .CarOperationResult result = 1;
inline void CarOperationResponse::clear_result() {
  _impl_.result_ = 0;
}
inline ::CarOperationResult CarOperationResponse::_internal_result() const {
  return static_cast< ::CarOperationResult >(_impl_.result_);
}
inline ::CarOperationResult CarOperationResponse::result() const {
  // @@protoc_insertion_point(field_get:CarOperationResponse.result)
  return _internal_result();
}
inline void CarOperationResponse::_internal_set_result(::CarOperationResult value) {
  
  _impl_.result_ = value;
}
inline void CarOperationResponse::set_result(::CarOperationResult value) {
  _internal_set_result(value);
  // @@protoc_insertion_point(field_set:CarOperationResponse.result)
}

// -------------------------------------------------------------------

// GetUserDataRequest

// int32 u_id = 1;
inline void GetUserDataRequest::clear_u_id() {
  _impl_.u_id_ = 0;
}
inline int32_t GetUserDataRequest::_internal_u_id() const {
  return _impl_.u_id_;
}
inline int32_t GetUserDataRequest::u_id() const {
  // @@protoc_insertion_point(field_get:GetUserDataRequest.u_id)
  return _internal_u_id();
}
inline void GetUserDataRequest::_internal_set_u_id(int32_t value) {
  
  _impl_.u_id_ = value;
}
inline void GetUserDataRequest::set_u_id(int32_t value) {
  _internal_set_u_id(value);
  // @@protoc_insertion_point(field_set:GetUserDataRequest.u_id)
}

// -------------------------------------------------------------------

// GetUserDataResponse

// repeated .CarInfo car_info_arr = 1;
inline int GetUserDataResponse::_internal_car_info_arr_size() const {
  return _impl_.car_info_arr_.size();
}
inline int GetUserDataResponse::car_info_arr_size() const {
  return _internal_car_info_arr_size();
}
inline void GetUserDataResponse::clear_car_info_arr() {
  _impl_.car_info_arr_.Clear();
}
inline ::CarInfo* GetUserDataResponse::mutable_car_info_arr(int index) {
  // @@protoc_insertion_point(field_mutable:GetUserDataResponse.car_info_arr)
  return _impl_.car_info_arr_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CarInfo >*
GetUserDataResponse::mutable_car_info_arr() {
  // @@protoc_insertion_point(field_mutable_list:GetUserDataResponse.car_info_arr)
  return &_impl_.car_info_arr_;
}
inline const ::CarInfo& GetUserDataResponse::_internal_car_info_arr(int index) const {
  return _impl_.car_info_arr_.Get(index);
}
inline const ::CarInfo& GetUserDataResponse::car_info_arr(int index) const {
  // @@protoc_insertion_point(field_get:GetUserDataResponse.car_info_arr)
  return _internal_car_info_arr(index);
}
inline ::CarInfo* GetUserDataResponse::_internal_add_car_info_arr() {
  return _impl_.car_info_arr_.Add();
}
inline ::CarInfo* GetUserDataResponse::add_car_info_arr() {
  ::CarInfo* _add = _internal_add_car_info_arr();
  // @@protoc_insertion_point(field_add:GetUserDataResponse.car_info_arr)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CarInfo >&
GetUserDataResponse::car_info_arr() const {
  // @@protoc_insertion_point(field_list:GetUserDataResponse.car_info_arr)
  return _impl_.car_info_arr_;
}

// -------------------------------------------------------------------

// AdminLoginRequest

// int32 p_id = 1;
inline void AdminLoginRequest::clear_p_id() {
  _impl_.p_id_ = 0;
}
inline int32_t AdminLoginRequest::_internal_p_id() const {
  return _impl_.p_id_;
}
inline int32_t AdminLoginRequest::p_id() const {
  // @@protoc_insertion_point(field_get:AdminLoginRequest.p_id)
  return _internal_p_id();
}
inline void AdminLoginRequest::_internal_set_p_id(int32_t value) {
  
  _impl_.p_id_ = value;
}
inline void AdminLoginRequest::set_p_id(int32_t value) {
  _internal_set_p_id(value);
  // @@protoc_insertion_point(field_set:AdminLoginRequest.p_id)
}

// string password = 2;
inline void AdminLoginRequest::clear_password() {
  _impl_.password_.ClearToEmpty();
}
inline const std::string& AdminLoginRequest::password() const {
  // @@protoc_insertion_point(field_get:AdminLoginRequest.password)
  return _internal_password();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AdminLoginRequest::set_password(ArgT0&& arg0, ArgT... args) {
 
 _impl_.password_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:AdminLoginRequest.password)
}
inline std::string* AdminLoginRequest::mutable_password() {
  std::string* _s = _internal_mutable_password();
  // @@protoc_insertion_point(field_mutable:AdminLoginRequest.password)
  return _s;
}
inline const std::string& AdminLoginRequest::_internal_password() const {
  return _impl_.password_.Get();
}
inline void AdminLoginRequest::_internal_set_password(const std::string& value) {
  
  _impl_.password_.Set(value, GetArenaForAllocation());
}
inline std::string* AdminLoginRequest::_internal_mutable_password() {
  
  return _impl_.password_.Mutable(GetArenaForAllocation());
}
inline std::string* AdminLoginRequest::release_password() {
  // @@protoc_insertion_point(field_release:AdminLoginRequest.password)
  return _impl_.password_.Release();
}
inline void AdminLoginRequest::set_allocated_password(std::string* password) {
  if (password != nullptr) {
    
  } else {
    
  }
  _impl_.password_.SetAllocated(password, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.password_.IsDefault()) {
    _impl_.password_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:AdminLoginRequest.password)
}

// -------------------------------------------------------------------

// AdminLoginResponse

// .LoginResult result = 1;
inline void AdminLoginResponse::clear_result() {
  _impl_.result_ = 0;
}
inline ::LoginResult AdminLoginResponse::_internal_result() const {
  return static_cast< ::LoginResult >(_impl_.result_);
}
inline ::LoginResult AdminLoginResponse::result() const {
  // @@protoc_insertion_point(field_get:AdminLoginResponse.result)
  return _internal_result();
}
inline void AdminLoginResponse::_internal_set_result(::LoginResult value) {
  
  _impl_.result_ = value;
}
inline void AdminLoginResponse::set_result(::LoginResult value) {
  _internal_set_result(value);
  // @@protoc_insertion_point(field_set:AdminLoginResponse.result)
}

// -------------------------------------------------------------------

// AdminGetDataRequest

// int32 p_id = 1;
inline void AdminGetDataRequest::clear_p_id() {
  _impl_.p_id_ = 0;
}
inline int32_t AdminGetDataRequest::_internal_p_id() const {
  return _impl_.p_id_;
}
inline int32_t AdminGetDataRequest::p_id() const {
  // @@protoc_insertion_point(field_get:AdminGetDataRequest.p_id)
  return _internal_p_id();
}
inline void AdminGetDataRequest::_internal_set_p_id(int32_t value) {
  
  _impl_.p_id_ = value;
}
inline void AdminGetDataRequest::set_p_id(int32_t value) {
  _internal_set_p_id(value);
  // @@protoc_insertion_point(field_set:AdminGetDataRequest.p_id)
}

// -------------------------------------------------------------------

// AdminGetDataResponse

// .ParkingInfo p_info = 1;
inline bool AdminGetDataResponse::_internal_has_p_info() const {
  return this != internal_default_instance() && _impl_.p_info_ != nullptr;
}
inline bool AdminGetDataResponse::has_p_info() const {
  return _internal_has_p_info();
}
inline void AdminGetDataResponse::clear_p_info() {
  if (GetArenaForAllocation() == nullptr && _impl_.p_info_ != nullptr) {
    delete _impl_.p_info_;
  }
  _impl_.p_info_ = nullptr;
}
inline const ::ParkingInfo& AdminGetDataResponse::_internal_p_info() const {
  const ::ParkingInfo* p = _impl_.p_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::ParkingInfo&>(
      ::_ParkingInfo_default_instance_);
}
inline const ::ParkingInfo& AdminGetDataResponse::p_info() const {
  // @@protoc_insertion_point(field_get:AdminGetDataResponse.p_info)
  return _internal_p_info();
}
inline void AdminGetDataResponse::unsafe_arena_set_allocated_p_info(
    ::ParkingInfo* p_info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.p_info_);
  }
  _impl_.p_info_ = p_info;
  if (p_info) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:AdminGetDataResponse.p_info)
}
inline ::ParkingInfo* AdminGetDataResponse::release_p_info() {
  
  ::ParkingInfo* temp = _impl_.p_info_;
  _impl_.p_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ParkingInfo* AdminGetDataResponse::unsafe_arena_release_p_info() {
  // @@protoc_insertion_point(field_release:AdminGetDataResponse.p_info)
  
  ::ParkingInfo* temp = _impl_.p_info_;
  _impl_.p_info_ = nullptr;
  return temp;
}
inline ::ParkingInfo* AdminGetDataResponse::_internal_mutable_p_info() {
  
  if (_impl_.p_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::ParkingInfo>(GetArenaForAllocation());
    _impl_.p_info_ = p;
  }
  return _impl_.p_info_;
}
inline ::ParkingInfo* AdminGetDataResponse::mutable_p_info() {
  ::ParkingInfo* _msg = _internal_mutable_p_info();
  // @@protoc_insertion_point(field_mutable:AdminGetDataResponse.p_info)
  return _msg;
}
inline void AdminGetDataResponse::set_allocated_p_info(::ParkingInfo* p_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.p_info_;
  }
  if (p_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(p_info);
    if (message_arena != submessage_arena) {
      p_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, p_info, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.p_info_ = p_info;
  // @@protoc_insertion_point(field_set_allocated:AdminGetDataResponse.p_info)
}

// repeated .ParkingSpaceInfo s_info_arr = 2;
inline int AdminGetDataResponse::_internal_s_info_arr_size() const {
  return _impl_.s_info_arr_.size();
}
inline int AdminGetDataResponse::s_info_arr_size() const {
  return _internal_s_info_arr_size();
}
inline void AdminGetDataResponse::clear_s_info_arr() {
  _impl_.s_info_arr_.Clear();
}
inline ::ParkingSpaceInfo* AdminGetDataResponse::mutable_s_info_arr(int index) {
  // @@protoc_insertion_point(field_mutable:AdminGetDataResponse.s_info_arr)
  return _impl_.s_info_arr_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ParkingSpaceInfo >*
AdminGetDataResponse::mutable_s_info_arr() {
  // @@protoc_insertion_point(field_mutable_list:AdminGetDataResponse.s_info_arr)
  return &_impl_.s_info_arr_;
}
inline const ::ParkingSpaceInfo& AdminGetDataResponse::_internal_s_info_arr(int index) const {
  return _impl_.s_info_arr_.Get(index);
}
inline const ::ParkingSpaceInfo& AdminGetDataResponse::s_info_arr(int index) const {
  // @@protoc_insertion_point(field_get:AdminGetDataResponse.s_info_arr)
  return _internal_s_info_arr(index);
}
inline ::ParkingSpaceInfo* AdminGetDataResponse::_internal_add_s_info_arr() {
  return _impl_.s_info_arr_.Add();
}
inline ::ParkingSpaceInfo* AdminGetDataResponse::add_s_info_arr() {
  ::ParkingSpaceInfo* _add = _internal_add_s_info_arr();
  // @@protoc_insertion_point(field_add:AdminGetDataResponse.s_info_arr)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ParkingSpaceInfo >&
AdminGetDataResponse::s_info_arr() const {
  // @@protoc_insertion_point(field_list:AdminGetDataResponse.s_info_arr)
  return _impl_.s_info_arr_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::Alarm> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Alarm>() {
  return ::Alarm_descriptor();
}
template <> struct is_proto_enum< ::LoginResult> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::LoginResult>() {
  return ::LoginResult_descriptor();
}
template <> struct is_proto_enum< ::RegistrationResult> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::RegistrationResult>() {
  return ::RegistrationResult_descriptor();
}
template <> struct is_proto_enum< ::CarOperation> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::CarOperation>() {
  return ::CarOperation_descriptor();
}
template <> struct is_proto_enum< ::CarOperationResult> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::CarOperationResult>() {
  return ::CarOperationResult_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_service_2eproto
